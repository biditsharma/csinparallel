% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Parallel Processes in Python Documentation}
\date{August 02, 2015}
\release{}
\author{CSInParallel Project}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\emph{Author}:

\begin{DUlineblock}{0em}
\item[] Steven Bogaerts
\item[] Department of Computer Science
\item[] DePauw University
\item[] 602 S. College Ave, Greencastle, IN  46135, U.S.A.
\end{DUlineblock}


\chapter{For Instructors}
\label{index:parallel-processes-in-python}\label{index:for-instructors}
This module examines some key concepts of parallelism that have particularly accessible Python implementations, making it suitable for an introductory computer science course (CS1). It considers how to create processes to work in parallel, how to use locks to manage access to shared resources, and how to pass data between processes. This is done using the \code{multiprocessing} module in Python.

\emph{Note:} The code examples in this module conform to \textbf{Python 2}.


\chapter{For Students}
\label{index:for-students}
You are about to study some key ideas of parallel computation. More specifically, we'll build on the knowledge of Python you've already gained, to see how to create programs that can make use of special computer hardware to literally do multiple things at the same time. We'll learn how to do this in Python using the \code{multiprocessing} module, but the ideas we explore here are broadly applicable. Thus they will serve a nice foundation for more study in future courses.

Start at the beginning section linked in the Contents below and work your way through, trying examples and stopping to complete code that you are asked to work on along the way.  You should work through this tutorial by having your Python programming environment available as you read-- this is designed for you to learn by doing.


\chapter{Learning Goals}
\label{index:learning-goals}

\section{Base Knowledge}
\label{index:base-knowledge}
Students should be able to:
\begin{itemize}
\item {} 
Describe what a process is and how a running program can involve many
processes.

\item {} 
Describe why order of execution of multiple idependent processes is not guaranteed.

\item {} 
Describe the challenge of shared resources in parallel computation.

\item {} 
Describe the purpose of interprocess communication.

\end{itemize}


\section{Conceptual/Applied Knowledge}
\label{index:conceptual-applied-knowledge}
Students should be able to:
\begin{itemize}
\item {} 
Write embarrassingly parallel programs in Python using the
multiprocessing module.

\item {} 
Manage access to a shared resource via a lock.

\item {} 
Write programs involving simple interprocess communication via a
shared queue.

\end{itemize}


\chapter{Prerequisites and Assumed Level}
\label{index:prerequisites-and-assumed-level}
At a minimum, students should have introductory-level experience in
printing, variables, tuples, and writing and using functions with
keyword arguments. Some basic understanding of object-oriented
programming is also helpful: classes, methods, object state,
constructors, and method invocation. For example, it would be quite
sufficient for students to be able to write a “Student” class with major
and GPA fields and supporting accessors and mutators.


\chapter{Contents}
\label{index:contents}

\section{Basics of Processes with Python}
\label{ProcessesBasics::doc}\label{ProcessesBasics:basics-of-processes-with-python}
Think about a time you worked with other people on some task. For
example, you might have worked with some friends to shovel a driveway or
complete a class project. You split the task into pieces, and each
person worked at the same time to get the job done more quickly than
would be possible by yourself. This is parallelism. In computing,
\emph{parallelism} can be defined as the use of multiple processing units
working together to complete some task. There are many different kinds
of hardware that can serve as a “processing unit”, but the principle is
the same: a task is broken into pieces in some way, and the processing
units cooperate on those pieces to get the task done.

Every computing device has a central processing unit (CPU) that handles
the running of a program. Have you heard of desktop computers or mobile
devices being described as “dual-core” or “quad-core”? This is a
reference to the number of processing units available on the CPU of that
device. A computer with a dual-core CPU has two cores – two processing
units – capable of working at the same time. Similarly, a quad-core CPU
has four cores.

The challenge is that these cores don’t get used to their greatest
benefit automatically. Programs need to be written in a particular way
to make effective use of the available cores. In this course module,
we’ll explore the use of the multiprocessing module in Python to write
programs that can execute on multiple cores.

Before we dive into programming, let’s consider what a \emph{process} is.
While the details can be rather complex and dependent on many factors,
the big picture is simple. We can think of a process as a running
program. A process has to keep track of what line in the code will be
executed next, and what variable values are set. On a single-core
processor, only one process actually runs at a time. This is in contrast
to a multicore processor, in which multiple processes can be executed
literally at the same time (limited by the number of cores, of course).


\subsection{Making a Process}
\label{ProcessesBasics:making-a-process}
We are now ready to work with the \code{multiprocessing} module itself. Let’s
consider the code below. First note that we
use \code{from multiprocessing import *} to gain access to the multiprocessing
module. This will give us access to many useful tools, including the
\code{current\_process} function and the \code{Process} class used in this
example.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{multiprocessing} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{k}{def} \PYG{n+nf}{sayHi}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}

\PYG{k}{def} \PYG{n+nf}{procEx}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{(parent process)}\PYG{l+s}{"}

    \PYG{n}{otherProc} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{otherProc}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This code follows a common pattern: a \emph{parent} process creates one or
more \emph{child} processes to do some task. In this example, suppose we call
\code{procEx}. The first line in that function prints a simple message about
what process is running. This is done by calling the function
\code{current\_process} that is defined in the multiprocessing module. The
\code{current\_process} function returns a Process object representing the
currently running process. Every Process object has a public field
called \textbf{pid}, which stands for “process identifier”. Thus
\code{current\_process().pid} returns the pid for the currently running
process. This is what gets printed.

Proceeding to the next line of the \code{procEx} function, observe that the
\code{Process} constructor is called, passing two arguments by name. The
purpose of this constructor call is to create a new \code{Process} object to be
executed. The \code{target} argument specifies what function should be executed
when the process under construction is actually started. The \code{args}
argument is a tuple of the arguments to pass to the target function; since the \code{sayHi} target function
takes no arguments, args is an empty tuple in this example.

It is important to note that by calling the \code{Process} constructor, we have
\emph{created} a \code{Process} object, but we have not yet \emph{started} a new process.
That is, the process exists, but is not available to be run yet. The
process is actually started with the last line of \code{procEx}. The \code{start}
method is defined in the \code{Process} class. It changes the state of the
\code{Process} object on which it is called, such that the process is made
available for execution.

So to summarize, there are two steps to make a child process do some
task: A \code{Process} object must be created using the constructor, and then
started using the \code{start} method.

So what does the child process do? It executes the \code{sayHi} function, as
specified in the target argument of the \code{Process} constructor call. Thus
it simply prints a message showing its pid. Note we use the same
\code{current\_process().pid} code here as in the parent, but this code will be
executed by the child process, not the parent, and so the pid will be
different. If you call the \code{procEx} method, you should receive output
similar to the following:

\begin{Verbatim}[commandchars=\\\{\}]
Hi from process 3988 (parent process)
Hi from process 4828
\end{Verbatim}

Of course, your pids will likely be different, since these numbers are
arbitrarily assigned by the operating system.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try the code}

\medskip


\code{Download basic1.py} and try the above example on your system.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\subsection{Making Multiple Processes}
\label{ProcessesBasics:making-multiple-processes}
Let’s extend what we’ve just looked at a little bit with a short
exercise. Copy the code from the previous example and modify it
to create three processes, each of which says “hi”. Try this on your own
now, before reading on.


\section{Creating multiple child processes}
\label{MultipleProcesses:creating-multiple-child-processes}\label{MultipleProcesses::doc}
A solution to the previous exercise is the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{procEx2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{(parent process)}\PYG{l+s}{"}

    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p3} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p2}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p3}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Here we make three different \code{Process} objects. It is important to note that
each process uses the same \code{sayHi} function defined before, but each
process executes that function independent of the others. Each child
process will print its own unique pid.

Let’s push this a little further now, using a sayHi2 function that takes
an argument. Observe the following code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sayHi2}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}

\PYG{k}{def} \PYG{n+nf}{manyGreetings}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{(main process)}\PYG{l+s}{"}

    \PYG{n}{name} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Jimmy}\PYG{l+s}{"}
    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi2}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi2}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p3} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi2}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p2}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p3}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Note in the
\code{manyGreetings} function that we create three \code{Process} objects, but this
time the \code{args} argument is not an empty tuple, but rather a tuple with a
single value in it. (Recall that the comma after name is used in
single-element tuples to distinguish them from the other use of
parentheses: syntactic grouping.) With the \code{args} tuple set up in this
way, \code{name} is passed in for \code{n} in the \code{sayHi2} function. So the result here
is that each of the three child processes has the same name, “Jimmy”,
which is included in the child process’s output. Of course, we could
trivially pass distinct names to the children by adjusting the \code{args}
tuple accordingly.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try the code}

\medskip


\code{Download manyGreetings.py} and try the above example on your system.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\subsection{Variable Number of Processes}
\label{MultipleProcesses:variable-number-of-processes}
Let’s try another exercise now. Write a function that first asks for
your name, and then asks how many processes to spawn. That many
processes are created, and each greets you by name and gives its pid.
Try this on your own before moving on. \emph{Hint}: use a loop to create the number of desired child processes.


\section{Creating multiple child processes, part 2}
\label{MultipleProcesses2::doc}\label{MultipleProcesses2:creating-multiple-child-processes-part-2}
Here is a possible solution for creating a variable number of child processes:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{manyGreetings2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{name} \PYG{o}{=} \PYG{n+nb}{raw\PYGZus{}input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Enter your name: }\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{numProc} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{How many processes? }\PYG{l+s}{"}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{numProc}\PYG{p}{)}\PYG{p}{:}
        \PYG{p}{(}\PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi2}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\subsection{Anonymous Processes}
\label{MultipleProcesses2:anonymous-processes}
After obtaining the
user’s name and desired number of processes, we create and start that
many Process objects with a loop. Note in this case that the single line
of the loop body could also be written as two lines as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi2}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{p}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

We can say that the one-line version includes the use of \emph{anonymous}
Process objects. They are anonymous since the individual objects are
never stored in variables for later use. They are simply created and
started immediately. The one-line version might look confusing at first,
but note that (Process(target=sayHi2, args=(name,))) creates a Process
object. We’re then just calling the start method on that Process object,
instead of storing it in a variable and calling start on that variable.
For our purposes, the end result is the same.

Now, consider the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{numProc}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pi} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi2}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{pi}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

This would work as well, as it merely substitutes variable p in
the previous example for pi. However, it is important to point
out that this code does \textbf{not} actually create several variables, p0,
p1, p2, etc. Sometimes this kind of mistake happens because we’re
working in a different context now – parallel programming – but it’s
important to remember that the same programming principles you’ve
already learned continue to apply here. For example, consider the
following example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{grade} \PYG{o}{=} \PYG{l+m+mi}{97}
\end{Verbatim}

Clearly this code does not create the variables gr0de, gr1de, gr2de,
etc. Similarly, then, pi does not become p0, p1, p2, etc.

Another important question can be considered in reviewing
the \code{manyGreetings2} code above again. Which approach is better, the
explicit use of p, or the anonymous version given in the original? It depends. In this
example, we don’t need access to the \code{Process} objects later, so there’s
no need to store them. So the anonymous version is acceptable in that
regard. But we might also think about which version we find to be more
readable. To an extent this may be a matter of personal opinion, but it
is something that should be considered in programming.


\section{Execution Order and Resource Contention}
\label{ExecutionOrderAndResources:execution-order-and-resource-contention}\label{ExecutionOrderAndResources::doc}
In addition to a pid, we also have the option of naming each child
process. Any provided name is stored in the public name field defined in
the \code{Process} class. For example, consider the following code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sayHi3}\PYG{p}{(}\PYG{n}{personName}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{personName}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{- pid}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}

\PYG{k}{def} \PYG{n+nf}{manyGreetings3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{(parent process)}\PYG{l+s}{"}

    \PYG{n}{personName} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{Jimmy}\PYG{l+s}{"}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi3}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{personName}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

If we run \code{manyGreetings3}, the parent process
says “Hi”, and then creates and starts ten child processes. Each child
process runs \code{sayHi3}, which requires a personName argument, specified in
the args parameter of the Process constructor call. We also include one
new argument in the Process constructor call: \code{name}. This \code{name} argument should be a
string, and in this example we just use the string representation of the
loop index variable i. Thus when a child process executes \code{sayHi3}, it has
access to the \code{personName} given as an argument, and also has access to
the \code{name} field provided in the call to the \code{Process} constructor.

Try to predict what will happen when you run the \code{manyGreetings3} function. Your first guess might be the following
(with arbitrary pids, of course):

\begin{Verbatim}[commandchars=\\\{\}]
Hi from process 3988 (main process)
Hi Jimmy from process 0 pid 5164
Hi Jimmy from process 1 pid 5236
Hi Jimmy from process 2 pid 6884
Hi Jimmy from process 3 pid 3652
Hi Jimmy from process 4 pid 1060
Hi Jimmy from process 5 pid 1767
Hi Jimmy from process 6 pid 5812
Hi Jimmy from process 7 pid 4732
Hi Jimmy from process 8 pid 3564
Hi Jimmy from process 9 pid 4332
\end{Verbatim}

It’s possible that the processes will print out very nicely and in order
like the above, but it’s extremely unlikely. First note that each core
of the CPU is a \emph{scarce resource}, meaning there aren’t typically enough
cores for every process to use one whenever it wants. On a quad-core
system, for example, up to four processes can execute at once. If there
are more than four processes wanting to execute, some will need to wait.

So the operating system maintains a list of waiting processes. When a
core becomes available, the operating system chooses another process to
execute on that core. But the process created first is not necessarily
the next one chosen. That is, just because we \emph{create and start} the
processes in the order 0 through 9 in our program, it doesn’t mean that
the operating system will choose them to \emph{execute} in the order 0
through 9. So, for example, we might expect output like this:

\begin{Verbatim}[commandchars=\\\{\}]
Hi from process 3988 (parent process)
Hi Jimmy from process 8 pid 3564
Hi Jimmy from process 2 pid 6884
Hi Jimmy from process 6 pid 5812
Hi Jimmy from process 0 pid 5164
Hi Jimmy from process 3 pid 3652
Hi Jimmy from process 9 pid 4332
Hi Jimmy from process 4 pid 1060
Hi Jimmy from process 7 pid 4732
Hi Jimmy from process 1 pid 5236
Hi Jimmy from process 5 pid 1767
\end{Verbatim}

In fact, any ordering of the child processes’ messages is possible. The
only thing we know for certain is that the message from the parent
process will show up first, since our code specifies that that should
happen before we create any child processes. There are ways to ensure
that certain tasks are completed before other tasks, as we’ll see later
in this module. But by default,
\emph{child processes execute in arbitrary order}, and parallel programs must be designed with this in mind.

Unfortunately, we still haven’t captured what will likely happen when we
run the code given above. Go ahead and run it now and
see. Results will vary, but you may see something very garbled up like
the following:

\begin{Verbatim}[commandchars=\\\{\}]
Hi from process 3988 (main process)
Hi HJHimmyiHii   Jimmy  from process 0 -JfJ pid 5164
immyrom process 4 - pid 4332
immy from process  from process 7 - pid8  5236- pid
 3564
Hi Jimmy from process 1 - pidH 6884
i Jimmy from process 5 - pid 3652
Hi Jimmy from process 5 - pid 1060
Hi Jimmy from process 2 - pid 176
Hi Jimmy from process 3 - pid 5812
Hi Jimmy from process 9 - pid 4732
\end{Verbatim}

What’s going on? The first thing to realize is that the CPU cores are
not the only scarce resource here. Standard output – where printing
occurs – is also scarce. More specifically, standard output is a single
\emph{shared} resource that multiple processes are trying to access at the
same time. So the processes have to take turns. As it is, our program is
not forcing the processes to take turns in any reasonable way. How can
we fix this? We’ll use a \emph{lock}.


\subsection{Using a Lock to Control Printing}
\label{ExecutionOrderAndResources:using-a-lock-to-control-printing}
One excellent way to begin our study of locks is by analogy to a concept
from the novel by William Golding (or the 1963 and 1990 film
adaptations). The novel tells the story of a group of boys shipwrecked
on a deserted island with no adult survivors. Before an eventual
breakdown into savagery, the boys conduct regular meetings to decide on
issues facing the group. The boys quickly realize that, left unchecked,
such meetings will be unproductive as multiple boys wish to speak at the
same time. Thus a rule is developed: Only the boy that is holding a
specially-designated conch shell is allowed to speak. When that boy is
finished speaking, he relinquishes the conch so that another boy may
speak. Thus order is maintained at the meetings as long as the boys
abide by these rules. We can also imagine what would happen if this
conch were not used: chaos in meetings as the boys try to shout above
each other. (And in fact this does happen in the story.)

It requires only a slight stretch of the events in this novel to make an
analogy to the coordination of multiple processes accessing a shared
resource, like standard output. In programming terms, each boy is a
separate process, having his own things he wishes to say at the meeting.
But the air around the meeting is a shared resource - all boys speak
into the same space. So there is contention for the shared resource that
is this space. Control of this shared resource is handled via the
single, special conch shell. The conch shell is a \emph{lock} – only one boy
may hold it at a time. When he releases it, indicating that he is done
speaking, some other boy may pick it up. Boys that are waiting to pick
up the conch are not allowed to say anything – they just have to wait
until whoever has the conch releases it. Of course, several boys may be
waiting for the conch at the same time, and only one of them will
actually get it next. So some boys might have to continue to wait
through multiple speakers.

The following code shows the analogous idea in Python.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sayHi4}\PYG{p}{(}\PYG{n}{lock}\PYG{p}{,} \PYG{n}{name}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lock}\PYG{o}{.}\PYG{n}{acquire}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}
    \PYG{n}{lock}\PYG{o}{.}\PYG{n}{release}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{manyGreetings4}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lock1} \PYG{o}{=} \PYG{n}{Lock}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hi from process}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{current\PYGZus{}process}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{(main process)}\PYG{l+s}{"}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{sayHi4}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{lock1}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{p}\PYG{l+s}{"}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

At
the start of \code{manyGreetings4}, the constructor of the \code{Lock} class is
called, with the resulting object stored in the variable \code{lock1}. This
single \code{Lock} object, along with a distinct name, is passed to each of the child
processes. Each child process wants to print something when it executes \code{sayHi4}. But
print writes to \code{stdout} (standard output), a single resource that is
shared among all the processes. So when multiple processes all want to
print at the same time, their output would be jumbled together were it
not for the lock, which ensures that only one process is able to execute
its print at a time.

How does the lock accomplish this? Through the use of the acquire and
release methods, both defined in the Lock class. Suppose process
$A$ acquires the lock and begins printing. If processes $B$,
$C$, and $D$ then execute their acquire calls while
$A$ has the lock, then $B$, $C$, and $D$ each
must wait. That is, each will \emph{block} on its acquire call. Once
$A$ releases the lock, one of the processes blocked on that lock
acquisition will arbitrarily be chosen to acquire the lock and print.
That process will then release the lock so that another blocked process
can proceed, and so on.

Note that the lock must be created in the parent process and then passed
to each child – this way each child process is referring to the same
lock. The alternative, in which each child constructs its own lock,
would be analogous to each boy bringing his own conch to a meeting.
Clearly this wouldn’t work.

As in the previous example, the order of execution of the processes is
still arbitrary. That is, the acquisition of the lock is arbitrary, and
so subsequent runs of the code are likely to
produce different orderings. It is not necessarily the process that was
created first, or that has been waiting the longest, that gets to
acquire the lock next.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try the code}

\medskip


\code{Download manyGreetings4.py} and try the above example on your system.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\subsection{You try it: Digging Holes}
\label{ExecutionOrderAndResources:you-try-it-digging-holes}
Let us now try an exercise extending the concept of locks above. Imagine
that you have 10 hole diggers, named $A$, $B$, $C$,
$D$, $E$, $F$, $G$, $H$, $I$, and
$J$. Think of each of these as a process, and write a function
assignDiggers() that creates 10 processes with these worker names
working on hole 0, 1, 2, ..., 9, respectively. Each one should print a
message about what it’s doing. When you’re done, you should get output
like the following (except that the order will be arbitrary):

\begin{Verbatim}[commandchars=\\\{\}]
Hiddy-ho!  I'm worker G and today I have to dig hole 6
Hiddy-ho!  I'm worker A and today I have to dig hole 0
Hiddy-ho!  I'm worker C and today I have to dig hole 2
Hiddy-ho!  I'm worker D and today I have to dig hole 3
Hiddy-ho!  I'm worker F and today I have to dig hole 5
Hiddy-ho!  I'm worker I and today I have to dig hole 8
Hiddy-ho!  I'm worker H and today I have to dig hole 7
Hiddy-ho!  I'm worker J and today I have to dig hole 9
Hiddy-ho!  I'm worker B and today I have to dig hole 1
Hiddy-ho!  I'm worker E and today I have to dig hole 4
\end{Verbatim}

Try to complete this exercise before moving on.


\section{Solution to Exercise}
\label{LockingExercise:solution-to-exercise}\label{LockingExercise::doc}
A solution is to the hole-digging exercise is as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dig}\PYG{p}{(}\PYG{n}{workerName}\PYG{p}{,} \PYG{n}{holeID}\PYG{p}{,} \PYG{n}{lock}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lock}\PYG{o}{.}\PYG{n}{acquire}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Hiddy-ho!  I}\PYG{l+s}{'}\PYG{l+s}{m worker}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{workerName}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{and today I have to dig hole}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{holeID}
    \PYG{n}{lock}\PYG{o}{.}\PYG{n}{release}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{assignDiggers}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lock} \PYG{o}{=} \PYG{n}{Lock}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{workerNames} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{A}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{B}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{C}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{D}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{E}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{F}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{G}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{H}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{I}\PYG{l+s}{"}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{J}\PYG{l+s}{"}\PYG{p}{]}

    \PYG{k}{for} \PYG{n}{holeID} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{workerNames}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{dig}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{workerNames}\PYG{p}{[}\PYG{n}{holeID}\PYG{p}{]}\PYG{p}{,} \PYG{n}{holeID}\PYG{p}{,} \PYG{n}{lock}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The \code{assignDiggers} function
creates a single Lock object and a list of the worker names. A process
is started for each worker, passing the appropriate name, assigned hole,
and the lock. Each worker attempts to acquire the lock, and is only
allowed to print once that acquisition succeeds. After printing, the
worker releases the lock so that another worker may print.

This exercise is also a good demonstration of the strengths and
limitations of different approaches to looping. The solution shown above uses what can be referred to as a
“loop-by-index” approach, in which the holeID index is the loop
variable. An alternative would be a “loop-by-element” (for-each loop)
approach, like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{c}{\PYGZsh{} Other code as before}
\PYG{k}{for} \PYG{n}{workerName} \PYG{o+ow}{in} \PYG{n}{workerNames}\PYG{p}{:}
    \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{dig}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{workerName}\PYG{p}{,} \PYG{n}{workerNames}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{workerName}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lock}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The loop-by-element
approach, however, is not as effective, because the
worker-Names.index(workerName) requires a fair amount of extra work to
execute. While the actual execution time will be nearly instantaneous in
both approaches for a small list, it is nevertheless a good idea to reiterate the general
principle of using the right programming constructs for maximum
efficiency.  You don't want to fall into the trap of using a less efficient choice on a larger list of data in some other circumstance, or in a circumstance where you might execute such a loop over and over many times, where the time used will add up.


\section{Communication}
\label{Communication:communication}\label{Communication::doc}
In most real-world applications of parallelism, some amount of
communication between processes is required. We have already seen one
way in which processes can communicate: a parent process can send data
to children through the args parameter of the Process constructor. Now
we are ready to look at a more flexible means of communication.

The Queue class (pronounced like the letter “Q”) defines a Queue object
that a parent can pass to children so that multiple processes have
access to it. A queue can be thought of as a collection of data. Any
process can put data onto the queue using the put method, and take data
off the queue using the get method. Thus one process could do a put, and
another a get, in order to transmit data. If a process attempts a get
when there is nothing on the queue, then the process will wait (\emph{block})
on the line of code where the get occurred until some other process does
a put on the queue.

Let’s look at this in the following example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{k}{def} \PYG{n+nf}{greet}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{(child process) Waiting for name...}\PYG{l+s}{"}
    \PYG{n}{name} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{(child process) Well, hi}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{name}

\PYG{k}{def} \PYG{n+nf}{sendName}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{greet}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{c}{\PYGZsh{} wait for 5 seconds}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{(parent process) Ok, I}\PYG{l+s}{'}\PYG{l+s}{ll send the name}\PYG{l+s}{"}
    \PYG{n}{q}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Jimmy}\PYG{l+s}{"}\PYG{p}{)}
\end{Verbatim}

Note the
use of a queue for communication between processes, which in this case is the variable \code{q}, which is a Python multiprocessing  \code{Queue} object. When \code{sendName} is
run, the following output results:

\begin{Verbatim}[commandchars=\\\{\}]
(child process) Waiting for name...
(parent process) Ok, I'll send the name
(child process) Well, hi Jimmy
\end{Verbatim}

At the start of the sendName function, the Queue constructor is called,
with the resulting Queue object stored in the variable q. This object is
passed to the child process. So the child process is in fact using the
same queue as the parent. The child is started, and then the parent does
nothing for 5 seconds, via the time.sleep(5) command. In the meantime,
since the child has started, the first print in greet is executed,
followed by the call to get. The child’s get is a \emph{blocking} command.
This means that the child process will go to sleep until it has a reason
to wake up – in this case, that there is something to get off the queue.
Since the parent sleeps for 5 seconds, the child ends up blocking for
approximately 5 seconds as well. Finally the parent process sends the
string “Jimmy”, the child process unblocks and stores “Jimmy” in the
variable name, and prints its final message.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try the code}

\medskip


\code{Download sendName.py} and try the above example on your system.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\subsection{Extended Communication Via a Queue}
\label{Communication:extended-communication-via-a-queue}
Let’s try some quick practice now that you’ve worked through the
previous example. Copy the code above as a basis for \code{greet2} and
\code{sendName2}. Modify the code so that \code{greet2} expects to receive 5 names,
which are sent by \code{sendName2}. Each function should accomplish this by
sending/receiving one name at a time, in a loop. Spend some time on this
before moving on.


\section{Queue Exercise Hint}
\label{QueueExerciseHint::doc}\label{QueueExerciseHint:queue-exercise-hint}
Did you get your code working? The exercise may feel challenging at
first because the context is new. Let’s try to organize our thoughts a
bit with some pseudocode:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{'''}
\PYG{l+s+sd}{def greet2():}
\PYG{l+s+sd}{    for 5 times}
\PYG{l+s+sd}{        get name from queue}
\PYG{l+s+sd}{        say hello}

\PYG{l+s+sd}{def sendName2():}
\PYG{l+s+sd}{    queue}
\PYG{l+s+sd}{    make a child process, give it the queue}
\PYG{l+s+sd}{    start it}

\PYG{l+s+sd}{    for 5 times}
\PYG{l+s+sd}{        sleep for a bit}
\PYG{l+s+sd}{        put another name in the queue}
\PYG{l+s+sd}{'''}
\end{Verbatim}

When we work in psuedocode, it frees us from having to think about new
syntax and other details all at once. Instead we’re free to get some big
picture ideas down first. In the above psuedocode you can see that
the parent process, in \code{sendName2}, will make a queue and a child process.
It will then loop five times, sending one piece of data at a time to the
child via the queue. The child, in \code{greet2}, will also loop five times,
getting something from the queue and printing. Recall that if the child
attempts to get something from the queue when there’s nothing there, it
will block until something is available to get. If you didn’t already
solve this problem, try again now, using the pseudocode as a guide.

With this pseudocode developed, the actual code comes much more easily.


\section{Queue Exercise Solution}
\label{QueueExerciseSolution:queue-exercise-solution}\label{QueueExerciseSolution::doc}
Recall the English pseudocode for our original simple examle problem
of sending 5 pieces of data from a parent to a child process:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{'''}
\PYG{l+s+sd}{def greet2():}
\PYG{l+s+sd}{    for 5 times}
\PYG{l+s+sd}{        get name from queue}
\PYG{l+s+sd}{        say hello}

\PYG{l+s+sd}{def sendName2():}
\PYG{l+s+sd}{    queue}
\PYG{l+s+sd}{    make a child process, give it the queue}
\PYG{l+s+sd}{    start it}

\PYG{l+s+sd}{    for 5 times}
\PYG{l+s+sd}{        sleep for a bit}
\PYG{l+s+sd}{        put another name in the queue}
\PYG{l+s+sd}{'''}
\end{Verbatim}

Here is a Python solution that follows the structure of
the pseudocode very closely. It’s just a matter of filling in the syntax
we’re learning for queues, along with a review of working with
processes and how we can sleep for a randomly defined amount of time.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}

\PYG{k}{def} \PYG{n+nf}{greet2}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{(child process) Waiting for name}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{i}
        \PYG{n}{name} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{(child process) Well, hi}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{name}

\PYG{k}{def} \PYG{n+nf}{sendName2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{greet2}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{q}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{(main process) Ok, I}\PYG{l+s}{'}\PYG{l+s}{ll send the name}\PYG{l+s}{"}
        \PYG{n}{q}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{George}\PYG{l+s}{"}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try the code}

\medskip


\code{Download sendName2.py} and try the above example on your system.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}

Once you are comfortable with this example of using queues to communicate data and coordinate the handling of that data using \code{put} and \code{get}, you will be ready to look at some other coordination mechanisms in the next section.


\section{Coordination of Processes}
\label{Coordination:coordination-of-processes}\label{Coordination::doc}

\subsection{The Join Method}
\label{Coordination:the-join-method}
In parallel programming, a \emph{join} operation instructs the executing
process to block until the process on which the join is called
completes. For example, if a parent process creates a child process in
variable \code{p1} and then calls \code{p1.join()}, then the parent process will block
on that join call until p1 completes. One important point to emphasize
again in this example is that the \emph{parent} process blocks, not the
process on which join is called (\code{p1}). Hence the careful language at the
start of this paragraph: the executing process blocks until the process
on which the join is called completes.

The word “join” can be confusing sometimes. The following example
provides an analogy of the parent process waiting
(using join) for a “slowpoke” child process to catch up.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{slowpoke}\PYG{p}{(}\PYG{n}{lock}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{n}{lock}\PYG{o}{.}\PYG{n}{acquire}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Slowpoke: Ok, I}\PYG{l+s}{'}\PYG{l+s}{m coming}\PYG{l+s}{"}
    \PYG{n}{lock}\PYG{o}{.}\PYG{n}{release}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{haveToWait}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lock} \PYG{o}{=} \PYG{n}{Lock}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{slowpoke}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{lock}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Waiter: Any day now...}\PYG{l+s}{"}

    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Waiter: Finally! Geez.}\PYG{l+s}{"}
\end{Verbatim}

The child
process is slow due to the \code{time.sleep(10)} call. Note also the use of a
lock to manage the shared use of stdout.

It should be pointed out, however, that join is not always necessary for
process coordination. Often a similar result can be obtained by blocking
on a queue get, as described in the previous section and later in this section.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try the code}

\medskip


\code{Download haveToWait.py} and try the above example on your system.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\subsection{Obtaining a Result from a Single Child}
\label{Coordination:obtaining-a-result-from-a-single-child}
While earlier examples demonstrated a parent process sending data to a
child via a queue, this example allows us to practice the other way
around: a child that performs a computation which is then obtained by
the parent. Consider two functions: \code{addTwo-Numbers}, and \code{addTwoPar}.
\code{addTwoNumbers} takes two numbers as arguments, adds them, and places the
result on a queue (which was also passed as an argument). \code{addTwoPar} asks
the user to enter two numbers, passes them and a queue to addTwo-Numbers
in a new process, waits for the result, and then prints it.

Consider the following starting code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{addTwoNumbers}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} time.sleep(5) \PYGZsh{} In case you want to slow things down to see what is happening.}
    \PYG{n}{q}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{addTwoPar}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Enter first number: }\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{y} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Enter second number: }\PYG{l+s}{"}\PYG{p}{)}

    \PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{addTwoNumbers}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The parent passes two numbers inputted by the user, and a shared queue,
to a child process, \code{p1}, which will execute \code{addTwoNumbers}. The child process puts the sum of the numbers onto
the queue, with an optional sleep call before, to slow the computation
down for illustrative purposes.

Here is an exercise for you to consider
now: starting with the above code, which you can \code{download as addTwoPar.py}, write
code to make the parent obtain the result from the child and print it.
Do not move on until you have done this.


\section{Process Coordination, Part 2}
\label{Coordination2:process-coordination-part-2}\label{Coordination2::doc}

\subsection{Solution to Exercise}
\label{Coordination2:solution-to-exercise}
The completed exercise is as follows:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{addTwoNumbers}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} sleep(5) \PYGZsh{} In case you want to slow things down to see what is happening.}
    \PYG{n}{q}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{addTwoPar}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Enter first number: }\PYG{l+s}{"}\PYG{p}{)}
    \PYG{n}{y} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{Enter second number: }\PYG{l+s}{"}\PYG{p}{)}

    \PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{addTwoNumbers}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}

    \PYG{c}{\PYGZsh{} p1.join()}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{The sum is:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{result}
\end{Verbatim}

As you
can see, it requires only a small addition. The parent must call the get
method on the queue. Once the child has put something on the queue, the
parent’s get will succeed, and the variable result will get a value and
be printed.

Did you attempt to use join in your solution, as in the commented-out
line in the above solution? In this example the join is
not harmful, but is not required. This is because the get will already
cause the parent process to block until data is on the queue. So there’s
no need for the parent process to wait for the child to be finished with
a join as well. The get already causes the required wait.


\subsection{Using a Queue to Merge Multiple Child Process Results}
\label{Coordination2:using-a-queue-to-merge-multiple-child-process-results}
The following example is a nice extension of the one
above.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{multiprocessing} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k}{def} \PYG{n+nf}{addManyNumbers}\PYG{p}{(}\PYG{n}{numNumbers}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{numNumbers}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{s} \PYG{o}{=} \PYG{n}{s} \PYG{o}{+} \PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
    \PYG{n}{q}\PYG{o}{.}\PYG{n}{put}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{addManyPar}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{totalNumNumbers} \PYG{o}{=} \PYG{l+m+mi}{1000000}

    \PYG{n}{q} \PYG{o}{=} \PYG{n}{Queue}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p1} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{addManyNumbers}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{totalNumNumbers}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{Process}\PYG{p}{(}\PYG{n}{target}\PYG{o}{=}\PYG{n}{addManyNumbers}\PYG{p}{,} \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}\PYG{n}{totalNumNumbers}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{p1}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{p2}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{answerA} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{answerB} \PYG{o}{=} \PYG{n}{q}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{print} \PYG{l+s}{"}\PYG{l+s}{Sum:}\PYG{l+s}{"}\PYG{p}{,} \PYG{n}{answerA} \PYG{o}{+} \PYG{n}{answerB}
\end{Verbatim}

Here, the task is to add up a
large number of random numbers. This is accomplished by creating two
child processes, each of which is responsible for half of the work. Note
that a shared queue, plus half the total number of numbers, is passed to
each child. Each child creates many random numbers and adds them up,
putting the final sum on the queue. The parent makes two get calls, to
obtain the result from each child. Note that the parent will likely
block on at least the first get call, since it will need to wait until
one of the children finishes and places its result on the queue.

Here’s an interesting question to consider: which child’s result will be
in answerA and which in answerB? The answer is that this is
indeterminate. Whichever child process finishes first will have its
answer in answerA, and the other will be in answerB. This is not a
problem for commutative merging operations, like the addition of this
example, but of course could be a complication for non-commutative
merging.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try the code}

\medskip


\code{Download addManyPar.py} and try the above example on your system.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\subsection{Conclusion}
\label{Coordination2:conclusion}
Of course there are many places you could go next, but here we have seen
an introduction to parallel programming in Python using the
multiprocessing module. We’ve explored the parent-child model of
parallel programming, in which the parent creates many child processes
to perform some task. We’ve seen how shared resources lead to a need for
locks to ensure uninterrupted access. Finally, we’ve seen how to pass
data between processes, both via the Process constructor’s \code{args}
argument, and also through the use of a shared queue.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
