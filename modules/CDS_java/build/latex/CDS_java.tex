% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Concurrent Data Structures in Java}
\date{November 08, 2014}
\release{}
\author{CSInParallel Project}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\textbf{Prologue}

This lab activity asks you to complete some code provided so that it is able to crawl the web from a given starting URL.  You will start by completing a sequential version of this code.  Then you will work on a version that uses the libraries from java.util.concurrent to create a multi-threaded version.

\textbf{Prerequisites}

Some existing knowledge of the Java data structures LinkedList and ArrayList is necessary.

\textbf{Code}

Please download \code{ConcurrentDataStructures.jar}. Inside the src directory are two packages: one for the original sequential web crawler called lab/spider, and another for the threaded spider called lab/concurrentSpider. The first chapter linked below starts you out with the sequential spider using conventional Java data structures to hold the URLs it encounters. You will then continue on to create the threaded version, starting with this code provided.


\chapter{A Single-process Web Crawler, or Spider}
\label{TheSpiderLabonecrawler/TheSpiderLabonecrawler::doc}\label{TheSpiderLabonecrawler/TheSpiderLabonecrawler:concurrent-data-structures-in-java}\label{TheSpiderLabonecrawler/TheSpiderLabonecrawler:a-single-process-web-crawler-or-spider}
The World Wide web is aptly named when you consider the URL links
found in pages.  One page can have many links in it that take a
viewer to another page, which has more links, and so on, forming a
very large cyclic graph of interconnected pages.

In this lab you
will be finishing some code for a web crawler, or spider, that will
start with a ‘seed’ URL to a web page and read it to find links to
other pages.  Those links will be placed on a queue for further
processing (we’ll call this the \textbf{work} queue).  When the initial page
is processed, it is placed on another data structure to indicate
that it has been visited already-- this is the \textbf{finished} queue.
This process is repeated for the next
page whose link is on the work queue.

The code you will be given
uses a Java library for parsing html files and looking for links
(java.net.URL).


\section{To Start With}
\label{TheSpiderLabonecrawler/TheSpiderLabonecrawler:to-start-with}
Here are the files in the package lab.spider, which you will use as
your starting point. Place these files into your Java IDE as indicated
by your instructor.

\begin{Verbatim}[commandchars=\\\{\}]
AllWordsCounter.java    // contains a ‘dictionary’ to hold counts of how often a URL is encounterd

HttpHelper.java         // contains methods to read html pages and extract links; also can detect whether a URL is an image

RunSpider.java          // has main()

Spider.java             // the workhorse and the one you will be changing

TestHttpHelper.java     // JUnit test class

TestSpider.java         // JUnit test class

WordCount.java          // small helper class that holds a word and a count
\end{Verbatim}

The Spider.java class is the one that you should work on for this
assignment.  The RunSpider class contains main() and uses it.  As
the code stands now it doesn’t really do anything if you run it.

Examine the code in the files.  Begin by creating a class diagram
that shows which classes ‘use’ or ‘have’ one of the other classes.


\subsection{Java Collection Data Structures Used}
\label{TheSpiderLabonecrawler/TheSpiderLabonecrawler:java-collection-data-structures-used}
Become familiar with the data structures that are used in this program.
The diagram below illustrates them.

The class called \emph{AllWordsCounter}
is able to return an array of \emph{WordCount} objects, each of which contains two data elements:
a URL for a page, and a count of the number of times that URL was encountered by the crawler.
In the \textbf{Spider} class, the method \emph{getUrlCounts} will return this array, shown on the left in
the picture below.  This array can be used to examine what the spider encountered when it is
finished running.

The \textbf{Spider} class also contains a Queue called \textbf{work} and a List called \textbf{finished}.
The Spider will start at a given, predetermined page and read all the links to URLs on it (this
is called scraping the page, which you will implement in the \emph{processPage} method).
The links it finds, illustrated on the far upper right in the following diagram,
should be added to the \textbf{work} queue, and a counter for that link should be updated.

The \textbf{Spider} class will repeat this process in the \emph{crawl} method
by continuing to pull each URL to a page off the \textbf{work} queue, process it, and place
it in the \textbf{finished} queue.  This is done for a certain number of times as designated by the
integer called \emph{maxUrls}.
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{Spider1.png}
\caption{Single Spider accesses the data and does all the work}\end{figure}


\subsection{To Do}
\label{TheSpiderLabonecrawler/TheSpiderLabonecrawler:to-do}
Your task is to finish the Spider class by doing the following:
\begin{itemize}
\item {} 
Complete the processPage method.  When it works, one of the TestSpider unit tests should pass.

\item {} 
Complete the crawl() method.  When it works, both TestSpider unit tests should pass.

\end{itemize}

\begin{notice}{note}{Note:}
There are comments in these methods to help assist you.
\end{notice}

Once your unit tests pass, you should be able to run the code by executing
the main method of the RunSpider class,
which is currently ‘hard-coded’ to start at macalester.edu, and see
it produce the URLs found when crawling, along with how many times
it saw them.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try This:}

\medskip

\begin{itemize}
\item {} 
Experiment with this variable found in Spider:  maxurls     If you double it, how many new urls were encountered?  You might want to make a method that would answer this for you.

\item {} 
Experiment with the BEGNNING\_URL variable found in RunSpider by choosing some other pages of interest to you as starting points.

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\chapter{Improving the Spider}
\label{SpiderLabpart2/SpiderLabpart2:improving-the-spider}\label{SpiderLabpart2/SpiderLabpart2::doc}

\section{First Question: How much work is there?}
\label{SpiderLabpart2/SpiderLabpart2:first-question-how-much-work-is-there}
Once you have a completed working Spider, let’s examine how much
work it has to do.  Try some experiments in which you continue
using increasing values of maxUrls in the Spider.  Please note that
you can provide this value in its constructor.

\textbf{TO DO:}  Add a method to the
Spider that enables you to ask how many pages are still left to
work on in the ‘work’ queue.  You may also want to add a method to
know how many pages have been finished.

\textbf{TO DO:}  Change the RunSpider class to run some experiments with different
values of maxUrls by executing several Spiders, one right after the other,
with increasing numbers of URLs.  For each value of
maxUrls, report on how much work is left to do.  How quickly is our
single Spider overloaded with work?


\section{Multiple Spiders to the rescue}
\label{SpiderLabpart2/SpiderLabpart2:multiple-spiders-to-the-rescue}
Now let’s examine how we can use multiple spiders working at the
same time on this problem.  Your instructor will take a moment to
explain how we will use a technique called threads to run many
spiders at the same time, each of who will access the work,
finished, and urlCounter queue.  Then you will try this out.

\textbf{Note:} more details about the implementation can be found on the
next page, which you can get to by following `next' in the upper and lower
right of this page or going to the `Next Topic' in the menu on the left.

There is a new lab.concurrentSpider package included in the code.
Examine the \textbf{RunThreadedSpider} class.  Note that we now use
a Java class called a Thread to begin running multiple instances of
the \textbf{ConcurrentSpider}, one each per Thread that is started.
The Spider is now in this class called
ConcurrentSpider, and implements an interface called Runnable.

A \emph{key feature} of concurrently running Spiders is that they must
share the same data structures in order to work together.  To do
this, we need to place the data structures they are working on in
one class and create one instance of that class in
RunConcurrentSpider.  Then each new ‘Runnable’ ConcurrentSpider
will receive a reference to that class of shared data structures.
We provide a class called \textbf{SharedSpiderData} for this purpose.


\section{Can we share our original data structures?}
\label{SpiderLabpart2/SpiderLabpart2:can-we-share-our-original-data-structures}
We could attempt to use the original LinkedList and ArrayList data structures
and share those among the threads.  However, these are not `thread safe',
that is they are not guaranteed to behave properly when multiple threads are
accessing and updating them at the same time.


\section{Guaranteed implementation: Use concurrent data structures}
\label{SpiderLabpart2/SpiderLabpart2:guaranteed-implementation-use-concurrent-data-structures}
To ensure our code will work correctly using multiple threads, we will
use the new Java Concurrent Data
Structures from the package java.util.concurrent.  Begin with the
file SharedSpiderData to see the types of shared, thread-safe data
structures we will use for this version of the multi-threaded
crawler.


\subsection{To Do}
\label{SpiderLabpart2/SpiderLabpart2:to-do}
Finish the class called ConcurrentSpider so that it uses the new concurrent data structures when scraping
the pages and keeping track of what has finished.  You will need to discover what methods on the concurrent data structures (ArrayBlockingQueue, ConcurrentLinkedQueue) are available for adding and removing elements.

You will also find it useful to include the ability to have the RunThreadedSpider class be able to determine how much
overall work was completed.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Try This:}

\medskip

\begin{itemize}
\item {} 
You can try using different numbers of threads, depending on how much your machine can handle, by changing the NUM\_THREADS variable in the RunThreadedSpider class.

\item {} 
Experiment with the parameter found in ComcurrentSpider constructor:  \emph{maxUrls}     If you double it, how many new urls were encountered?  Now that you have all these spider threads, you can likely scrape more URLs.

\item {} 
Experiment with the BEGNNING\_URL variable found in RunSpider by choosing some other pages of interest to you as starting points.

\end{itemize}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\chapter{Using Multiple Processes}
\label{URLSpider/URLSpider:using-multiple-processes}\label{URLSpider/URLSpider::doc}

\section{Environment}
\label{URLSpider/URLSpider:environment}\begin{enumerate}
\item {} 
On Machines with multiple cores,

\end{enumerate}
\begin{itemize}
\item {} \begin{description}
\item[{\textbf{Threads} within a program can enable concurrency}] \leavevmode\begin{itemize}
\item {} 
Run in parallel on multiple cores

\end{itemize}

\end{description}

\item {} 
Threads can share data in memory

\item {} \begin{description}
\item[{Ideally, needed work can get done faster}] \leavevmode\begin{itemize}
\item {} \begin{description}
\item[{There is a \textbf{speedup} in the computation when using multiple threads as opposed to using 1 thread}] \leavevmode\begin{itemize}
\item {} 
We measure speedup by taking the time to run the original non-threaded version and dividing it by the time to run the threaded version.

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Threads are not a concept associated with clusters of machines, only multicore machines

\end{enumerate}


\section{Executing sequentially (original non-threaded version)}
\label{URLSpider/URLSpider:executing-sequentially-original-non-threaded-version}\begin{figure}[htbp]
\centering
\capstart

\includegraphics{Spider11.png}
\caption{Single Spider accesses the data and does all the work}\end{figure}


\section{One spider}
\label{URLSpider/URLSpider:one-spider}\begin{enumerate}
\item {} 
The original web crawling spider that you’ve been working on looks like this:

\end{enumerate}
\begin{itemize}
\item {} \begin{description}
\item[{3 data structures holding information}] \leavevmode\begin{itemize}
\item {} 
Accessed individually by the Spider class

\end{itemize}

\end{description}

\item {} 
The Spider class does all the work, one step at a time

\item {} \begin{description}
\item[{In this case, the ‘work’ is piling up!}] \leavevmode\begin{itemize}
\item {} 
Each page that is visited has many more links to follow

\end{itemize}

\end{description}

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
What might make this process faster so that more work gets done?

\end{enumerate}


\section{Executing concurrently}
\label{URLSpider/URLSpider:executing-concurrently}\begin{figure}[htbp]
\centering
\capstart

\includegraphics{Spider2.png}
\caption{Multiple Spider ‘Runnable’ Threads all access the shared data}\end{figure}


\section{Multiple Spider `threads'}
\label{URLSpider/URLSpider:multiple-spider-threads}\begin{itemize}
\item {} \begin{description}
\item[{What happens when several threads need to read and write from the ‘work’ data structure?}] \leavevmode\begin{itemize}
\item {} 
Imagine yourself as a spider working with a group of others

\item {} \begin{description}
\item[{What actions are involved when you:}] \leavevmode\begin{itemize}
\item {} 
Grab a new page to work on from the work data structure

\item {} 
Save new links to the ‘work’ data structure

\item {} 
Store the completed page in ‘done’ data structure

\end{itemize}

\end{description}

\end{itemize}

\end{description}

\end{itemize}


\section{Key point: locking}
\label{URLSpider/URLSpider:key-point-locking}\begin{itemize}
\item {} \begin{description}
\item[{For certain operations on a shared data structure,}] \leavevmode\begin{itemize}
\item {} 
Other threads must be barred from accessing when another thread is executing that operation

\end{itemize}

\end{description}

\item {} 
These operations must be atomic: only one thread can be executing this operation at a time

\item {} 
Which operations on the work data structure should be atomic?

\end{itemize}


\section{How to do this in Java}
\label{URLSpider/URLSpider:how-to-do-this-in-java}

\subsection{Creating Threads in Java}
\label{URLSpider/URLSpider:creating-threads-in-java}\begin{itemize}
\item {} 
Build a class that implements the Runnable interface:

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
public interface Runnable \PYGZob{}
        abstract public void run();
\PYGZcb{}
\end{Verbatim}

In our case, this is called ConcurrentSpider
\begin{itemize}
\item {} 
In a class containing ‘main’, create each new thread and pass it a new instance of the `Runnable' ConcurrentSpider class

\end{itemize}


\subsection{Sharing the Data}
\label{URLSpider/URLSpider:sharing-the-data}\begin{itemize}
\item {} 
Create your shared data structures in a separate class

\item {} 
Create one instance of the shared data class in the ‘main’ class

\item {} 
Pass that instance of the shared data to each instance of the `Runnable' ConcurrentSpider class via the constructor

\end{itemize}


\subsection{The Shared Data}
\label{URLSpider/URLSpider:the-shared-data}\begin{itemize}
\item {} 
Java has special data structures designed to be shared by Threads

\item {} 
See the documentation for \href{http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/package-summary.html}{java.util.concurrent}

\item {} \begin{description}
\item[{We’re using:}] \leavevmode\begin{itemize}
\item {} 
ArrayBlockingQueue

\item {} 
ConcurrentLinkedQueue

\item {} 
(ConcurrentHashMap, inside another class provided for you to hold the counts of the URLs)

\end{itemize}

\end{description}

\end{itemize}


\section{Speedup}
\label{URLSpider/URLSpider:java-util-concurrent}\label{URLSpider/URLSpider:speedup}
Speedup is a number we can compute by running experiments.  It gives us an indication of how much faster
our threaded version is than our original `sequential' version with one Spider.

We measure speedup by taking the time to run the original non-threaded version and dividing it by the time to run the threaded version.  If when using 2 threads on the same number of URLS the code takes half the amount of time, we would have
perfect speedup of 2.  This rarely happens, and we expect our speedup to be less than perfect due to some amount of overhead
incurred when running threads that are updating shared data structures.
\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Dig Deeper:}

\medskip


Once you’ve implemented your solution,
\begin{enumerate}
\item {} 
Roughly determine the speedup of your threaded version

\end{enumerate}
\begin{itemize}
\item {} 
For varying numbers of threads, keeping the number of URLs processed constant

\item {} 
What will you need to measure?

\end{itemize}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Write a short report analyzing the speedup of your threaded solution

\end{enumerate}
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
