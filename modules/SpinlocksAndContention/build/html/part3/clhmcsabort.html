<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>A Second Helping of Soup &mdash; Spinlocks and Contention</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Spinlocks and Contention" href="../index.html" />
    <link rel="prev" title="Solving the Mystery and Using Our Findings" href="../part2/backoffandqueue.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../part2/backoffandqueue.html" title="Solving the Mystery and Using Our Findings"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Spinlocks and Contention</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="a-second-helping-of-soup">
<h1>A Second Helping of Soup<a class="headerlink" href="#a-second-helping-of-soup" title="Permalink to this headline">¶</a></h1>
<p>In this final section, we examine</p>
<div class="section" id="the-clh-lock">
<h2>The CLH Lock<a class="headerlink" href="#the-clh-lock" title="Permalink to this headline">¶</a></h2>
<p>The CLH queue lock (by Travis Craig, Anders Landin, and Erik Hagersten - many of these algorithms are named for their creators) is much more space-efficient since it incurs a small constant-size overhead per thread. It also provides FIFO fairness.</p>
<p>This algorithm records each thread&#8217;s status in a QNode object, which has a Boolean locked field. If that field is true, then the corresponding thread either has acquired the lock or is waiting for the lock. If that field is false, then the thread has released the lock. The lock itself is represented as a virtual linked list of QNode objects. We use the term &#8220;virtual&#8221; because the list is implicit: each thread points to its predecessor through a thread-local <tt class="docutils literal"><span class="pre">predvariable</span></tt>. The public tail variable points to the last node in the queue.</p>
<a class="reference internal image-reference" href="../_images/clh1to3.png"><img alt="CLH" class="align-center" src="../_images/clh1to3.png" style="width: 606.0px; height: 172.8px;" /></a>
<p>To acquire the lock, a thread sets the locked field of its QNode to true, meaning that the thread is not ready to release the lock.</p>
<a class="reference internal image-reference" href="../_images/clh4.png"><img alt="CLH" class="align-center" src="../_images/clh4.png" style="width: 168.8px; height: 148.0px;" /></a>
<p>The thread applies swap to the tail to make its own node the tail of the queue, simultaneously acquiring a reference to its predecessor&#8217;s QNode.</p>
<a class="reference internal image-reference" href="../_images/clh5.png"><img alt="CLH" class="align-center" src="../_images/clh5.png" style="width: 187.2px; height: 150.4px;" /></a>
<p>Because it sees that its predecessor’s QNode is false, this thread now has the lock.</p>
<a class="reference internal image-reference" href="../_images/clh6.png"><img alt="CLH" class="align-center" src="../_images/clh6.png" style="width: 171.2px; height: 172.8px;" /></a>
<p>Another thread that wants the lock does the same sequence of steps …</p>
<a class="reference internal image-reference" href="../_images/clh7.png"><img alt="CLH" class="align-left" src="../_images/clh7.png" style="width: 255.2px; height: 168.8px;" /></a>
<a class="reference internal image-reference" href="../_images/clh8.png"><img alt="CLH" class="align-right" src="../_images/clh8.png" style="width: 270.4px; height: 151.2px;" /></a>
<p>Note that the list is ordered implicitly - there are no real pointers between the nodes.</p>
<a class="reference internal image-reference" href="../_images/clh9.png"><img alt="CLH" class="align-center" src="../_images/clh9.png" style="width: 236.8px; height: 140.8px;" /></a>
<p>But each thread keeps a reference of the node it added to the list. So each thread has the node it was assigned from the swap and the reference to the node it added when the swap completed.</p>
<a class="reference internal image-reference" href="../_images/clh10.png"><img alt="CLH" class="align-center" src="../_images/clh10.png" style="width: 231.2px; height: 183.2px;" /></a>
<p>Again, the links are implicit, as shown below.</p>
<a class="reference internal image-reference" href="../_images/clh11.png"><img alt="CLH" class="align-center" src="../_images/clh11.png" style="width: 301.6px; height: 177.6px;" /></a>
<p>The waiting thread then spins on its predecessor&#8217;s QNode until the predecessor releases the lock.</p>
<a class="reference internal image-reference" href="../_images/clh12.png"><img alt="CLH" class="align-center" src="../_images/clh12.png" style="width: 232.0px; height: 194.4px;" /></a>
<p>The thread actually spins on a <em>cached</em> copy of purple&#8217;s node. This is very efficient in terms of interconnect traffic (unless you are on a NUMA architecture, where purple&#8217;s node may be on a different processor).</p>
<a class="reference internal image-reference" href="../_images/clh13.png"><img alt="CLH" class="align-center" src="../_images/clh13.png" style="width: 288.8px; height: 193.6px;" /></a>
<p>Some coherence protocols shared memory might not be updated at all, only the cached copy. This is very efficient.</p>
<a class="reference internal image-reference" href="../_images/clh14.png"><img alt="CLH" class="align-center" src="../_images/clh14.png" style="width: 296.8px; height: 176.8px;" /></a>
<p>When a thread acquires a lock it can reuse its predecessor&#8217;s QNode as its new node for future lock accesses. Note that it can do so since at this point the thread&#8217;s predecessor&#8217;s QNode will no longer be used by the predecessor, and the thread&#8217;s old QNode is pointed to either by the thread&#8217;s successor or by the tail.</p>
<a class="reference internal image-reference" href="../_images/clh15.png"><img alt="CLH" class="align-center" src="../_images/clh15.png" style="width: 231.2px; height: 179.2px;" /></a>
<p>The reuse of the QNode&#8217;s means that for <em>L</em> locks and <em>N</em> threads, if each thread accesses at most one lock at a time, we only need O(<em>L</em>+<em>N</em>) space as compared with  O(<em>LN</em>) for the ALock. Of course, this only holds for accessing one lock at a time. If you access all <em>L</em> locks, then you need a QNode for each access.</p>
<p>Here is what the code looks like as a Java object: if the locked field is true, the lock has not been released yet (it may also not have been acquired yet either).</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">Qnode</span> <span class="o">{</span>
        <span class="n">AtomicBoolean</span> <span class="n">locked</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>And here is the code for the lock:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">CLHLock</span> <span class="kd">implements</span> <span class="n">Lock</span> <span class="o">{</span>
        <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Qnode</span><span class="o">&gt;</span> <span class="n">tail</span><span class="o">;</span> <span class="c1">//tail of the queue</span>
        <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Qnode</span><span class="o">&gt;</span> <span class="n">myNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Qnode</span><span class="o">();</span>
        <span class="c1">//recall that ThreadLocal means that each thread has a private</span>
        <span class="c1">//instance of myNode, shared only by name and not reference)</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">Qnode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">myNode</span><span class="o">);</span> <span class="c1">//swap in myNode</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">locked</span><span class="o">)</span> <span class="o">{}</span> <span class="c1">//spin until predecessor releases lock</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">myNode</span><span class="o">.</span><span class="na">locked</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">//notify successor</span>
                <span class="n">myNode</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span> <span class="c1">//recycle predecessor&#39;s node</span>
                <span class="c1">//(notice that we don&#39;t actually reuse myNode in lock())</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>Like the ALock, this algorithm has each thread spin on a distinct location, so when one thread releases its lock, it invalidates its successor&#8217;s cache only, and does not invalidate any other thread&#8217;s cache. It does so with a lower space overhead, and, importantly, without requiring prior knowledge of the number of threads accessing a lock. It also provides first-come-first-served fairness.</p>
<p>To understand the principal disadvantage of this lock algorithm, we need to know a little more about non-uniform memory (NUMA) architectures. NUMA architectures tend to be described as if they have flat shared memory, but the truth is that not all have caches, and some regions of memory are faster than others. The principal disadvantage of the CLHLock algorithm is that it performs poorly on cacheless NUMA architectures -   each thread spins waiting for its predecessors&#8217; nodes to become false. If this memory location is remote, then performance will suffer.</p>
<a class="reference internal image-reference" href="../_images/numatiming.png"><img alt="CLH" class="align-center" src="../_images/numatiming.png" style="width: 375.2px; height: 192.8px;" /></a>
<p>On cache-coherent architectures, however, this approach should work well.</p>
</div>
<div class="section" id="mcs-lock">
<h2>MCS Lock<a class="headerlink" href="#mcs-lock" title="Permalink to this headline">¶</a></h2>
<p>The MCS lock is another kind of queue lock that ensures that processes always spin on a fixed location in local memory, so this one works well for cacheless architectures. Like the CLH lock, it uses only a small fixed-size overhead per thread. It also provides FIFO fairness.</p>
<p>Here, too, the lock is represented as a linked list of QNodes, where each QNode represents either a lock holder or a thread waiting to acquire the lock. Unlike the CLH lock, the list is explicit, not virtual.</p>
<a class="reference internal image-reference" href="../_images/mcs1.png"><img alt="MCS" class="align-center" src="../_images/mcs1.png" style="width: 169.6px; height: 144.0px;" /></a>
<p>To acquire the lock, a thread places its own QNode at the tail of the list.</p>
<a class="reference internal image-reference" href="../_images/mcs2.png"><img alt="MCS" class="align-center" src="../_images/mcs2.png" style="width: 264.8px; height: 141.6px;" /></a>
<p>The node then swaps in a reference to its own QNode.</p>
<a class="reference internal image-reference" href="../_images/mcs3.png"><img alt="MCS" class="align-center" src="../_images/mcs3.png" style="width: 271.2px; height: 142.4px;" /></a>
<p>At this point the swap is completed, and the queue variable points to the tail of the queue.</p>
<a class="reference internal image-reference" href="../_images/mcs4.png"><img alt="MCS" class="align-center" src="../_images/mcs4.png" style="width: 260.8px; height: 160.8px;" /></a>
<p>To acquire the lock, a thread places its own QNode at the tail of the list. If there are no other QNodes on the list, it looks like this.</p>
<a class="reference internal image-reference" href="../_images/mcs5.png"><img alt="MCS" class="align-center" src="../_images/mcs5.png" style="width: 264.0px; height: 156.8px;" /></a>
<p>If a thread trying to acquire the lock has a predecessor, it modifies the predecessor&#8217;s node to refer back to its own QNode.</p>
<a class="reference internal image-reference" href="../_images/mcs6to7.png"><img alt="MCS" class="align-center" src="../_images/mcs6to7.png" style="width: 616.0px; height: 176.0px;" /></a>
<p>The predecessor&#8217;s node now refers to the red processor&#8217;s QNode.</p>
<a class="reference internal image-reference" href="../_images/mcs8.png"><img alt="MCS" class="align-center" src="../_images/mcs8.png" style="width: 294.4px; height: 156.8px;" /></a>
<p>The red processor now spins locally, waiting for its turn.</p>
<a class="reference internal image-reference" href="../_images/mcs9.png"><img alt="MCS" class="align-center" src="../_images/mcs9.png" style="width: 291.2px; height: 176.0px;" /></a>
<p>The purple node is the first node, and it finds the lock free, so its flag is already set to true (default on creation).</p>
<a class="reference internal image-reference" href="../_images/mcs10.png"><img alt="MCS" class="align-center" src="../_images/mcs10.png" style="width: 291.2px; height: 173.6px;" /></a>
<p>The red processor acquires the lock!</p>
<a class="reference internal image-reference" href="../_images/mcs11.png"><img alt="MCS" class="align-center" src="../_images/mcs11.png" style="width: 295.2px; height: 152.8px;" /></a>
<p>So now that we understand how it works, let&#8217;s take a look at the code. Here is the code for QNodes:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">Qnode</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">Qnode</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>And here is the code that uses the QNode to implement an MCSLock:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">MCSLock</span> <span class="kd">implements</span> <span class="n">Lock</span> <span class="o">{</span>
        <span class="n">AtomicReference</span> <span class="n">tail</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">Qnode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Qnode</span><span class="o">();</span> <span class="c1">//qnode should be a thread-local variable!</span>
                <span class="c1">//we&#39;ll need it in the unlock method.</span>
                <span class="n">Qnode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">);</span> <span class="c1">//add my node to the tail of queue</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">qnode</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">qnode</span><span class="o">;</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">locked</span><span class="o">)</span> <span class="o">{}</span> <span class="c1">//wait until unlocked</span>
                <span class="o">}</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>The only way the CAS will fail is if someone has changed the tail. The fact that the tail has now changed suggests that someone else is trying to acquire the lock, and we need to wait for them to set the next pointer.</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//no successor?</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">CAS</span><span class="o">(</span><span class="n">qnode</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">//if really no successor, return</span>
                <span class="k">return</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{}</span> <span class="c1">//Otherwise wait for successor to catch up</span>
                <span class="o">}</span>
        <span class="n">qnode</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//pass lock to successor</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>We&#8217;ll unpack unlocking with some more images. We left off here:</p>
<a class="reference internal image-reference" href="../_images/mcsunlock1.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock1.png" style="width: 265.6px; height: 134.4px;" /></a>
<p>The purple node looks at the queue.</p>
<a class="reference internal image-reference" href="../_images/mcsunlock2.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock2.png" style="width: 265.6px; height: 175.2px;" /></a>
<p>Red prepares to spin...</p>
<a class="reference internal image-reference" href="../_images/mcsunlock3.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock3.png" style="width: 263.2px; height: 140.0px;" /></a>
<a class="reference internal image-reference" href="../_images/mcsunlock4.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock4.png" style="width: 264.8px; height: 138.4px;" /></a>
<p>...and then spins!</p>
<a class="reference internal image-reference" href="../_images/mcsunlock5.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock5.png" style="width: 264.8px; height: 142.4px;" /></a>
<p>And red has acquired the lock!</p>
<a class="reference internal image-reference" href="../_images/mcsunlock6.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock6.png" style="width: 264.8px; height: 142.4px;" /></a>
</div>
<div class="section" id="a-final-real-world-complication-aborting-threads">
<h2>A Final Real-World Complication: Aborting Threads<a class="headerlink" href="#a-final-real-world-complication-aborting-threads" title="Permalink to this headline">¶</a></h2>
<p>The spinlock constructions we&#8217;ve looked at some far provide first-come-first-served (FIFO) access with little contention, making them useful in many applications. In <a class="reference external" href="http://en.wikipedia.org/wiki/Real-time_computing">real-time systems</a>, however, threads may require the ability to <em>abort</em>, canceling a pending request to acquire a lock in order to meet some other real-time deadline. Example reasons for giving up waiting for a lock could include a tiemout or a database transaction aborted by the user. Let&#8217;s look at implementing the option to abort on the locks we&#8217;ve examined so far:</p>
<p>Aborting a <span class="uline">backoff lock</span> request is trivial: if the request takes too long, simply return from the <tt class="docutils literal"><span class="pre">lock()</span></tt> method. The lock&#8217;s state is unaffected by any thread&#8217;s abort. A nice property of this lock is that the abort itself is immediate: it is wait-free, requiring only a constant number of steps, and there is no cleanup.</p>
<p>The <span class="uline">queue lock</span> is a little trickier, though: if we simply quit, the next thread in line will starve.</p>
<p>Under normal circumstances, recall, the queue lock works like this:</p>
<a class="reference internal image-reference" href="../_images/normalqueue.gif"><img alt="normal queue behavior." class="align-center" src="../_images/normalqueue.gif" style="width: 300.0px; height: 126.4px;" /></a>
<p>However, if we try to have a node in the middle abort, the subsequent threads run into problems:</p>
<a class="reference internal image-reference" href="../_images/abortqueue.gif"><img alt="queue with an aborting node" class="align-center" src="../_images/abortqueue.gif" style="width: 300.0px; height: 126.4px;" /></a>
<p>Instead, to create a CLHLock that can abort, we need a graceful way out. Removing a node in a wait-free manner from the middle of the list is difficult if we want that thread to reuse its own node. The initial state would look like this:</p>
<a class="reference internal image-reference" href="../_images/clhabort1.png"><img alt="clh with abort, initial" class="align-center" src="../_images/clhabort1.png" style="width: 268.8px; height: 159.2px;" /></a>
<p>The idling purple processor decides it wants to acquire the lock:</p>
<a class="reference internal image-reference" href="../_images/clhabort2.png"><img alt="clh with abort, acquiring" class="align-center" src="../_images/clhabort2.png" style="width: 160.8px; height: 141.6px;" /></a>
<p>Each thread allocates a new QNode for each lock access. A Null predecessor value means that the QNode is not aborted and has not yet completed executing the critical section.</p>
<a class="reference internal image-reference" href="../_images/clhabort3.png"><img alt="clh with abort, acquiring" class="align-center" src="../_images/clhabort3.png" style="width: 273.6px; height: 190.4px;" /></a>
<p>The purple predecessor can now acquire the lock:</p>
<a class="reference internal image-reference" href="../_images/clhabort4.png"><img alt="clh with abort, acquiring" class="align-center" src="../_images/clhabort4.png" style="width: 191.2px; height: 153.6px;" /></a>
<p>Success, but it took a lot of work.</p>
<a class="reference internal image-reference" href="../_images/clhabort5.png"><img alt="clh with abort, locked" class="align-center" src="../_images/clhabort5.png" style="width: 249.6px; height: 176.0px;" /></a>
<p>Instead, what if we let the successor deal with the recycling? Here we&#8217;ll see a CLH lock in which the aborting thread marks the node so that the successor in the list will reuse the abandoned node and wait for that node&#8217;s predecessor - the Timeout Lock.</p>
<a class="reference internal image-reference" href="../_images/to1.png"><img alt="to lock" class="align-center" src="../_images/to1.png" style="width: 249.6px; height: 176.0px;" /></a>
<p>The blue processor times out and aborts...</p>
<a class="reference internal image-reference" href="../_images/to2.png"><img alt="to lock" class="align-center" src="../_images/to2.png" style="width: 288.8px; height: 151.2px;" /></a>
<p>...but in this version its successor, the red processor, notices and takes over.</p>
<a class="reference internal image-reference" href="../_images/to3.png"><img alt="to lock" class="align-center" src="../_images/to3.png" style="width: 304.8px; height: 164.0px;" /></a>
<p>The red processor recycles its predecessor&#8217;s node...</p>
<a class="reference internal image-reference" href="../_images/to4.png"><img alt="to lock" class="align-center" src="../_images/to4.png" style="width: 288.8px; height: 110.4px;" /></a>
<p>...and begins to spin on the predecessor&#8217;s predecessor.</p>
<a class="reference internal image-reference" href="../_images/to5.png"><img alt="to lock" class="align-center" src="../_images/to5.png" style="width: 282.4px; height: 140.0px;" /></a>
<p>Here&#8217;s the code for this lock:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TOLock</span> <span class="kd">implements</span> <span class="n">Lock</span> <span class="o">{</span>
        <span class="kd">static</span> <span class="n">Qnode</span> <span class="n">AVAILABLE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Qnode</span><span class="o">();</span> <span class="c1">//Distinguished node to signify free lock</span>
        <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Qnode</span><span class="o">&gt;</span> <span class="n">tail</span><span class="o">;</span> <span class="c1">//Tail of the queue</span>
        <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Qnode</span><span class="o">&gt;</span> <span class="n">myNode</span><span class="o">;</span> <span class="c1">//Remember my node…</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>And the lock function looks like this:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">lock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
<span class="hll">        <span class="n">Qnode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Qnode</span><span class="o">();</span>
</span><span class="hll">        <span class="n">myNode</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">qnode</span><span class="o">);</span>
</span><span class="hll">        <span class="n">qnode</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span>        <span class="c1">//first three lines create and initialize node</span>
        <span class="n">Qnode</span> <span class="n">myPred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">);</span> <span class="c1">//Swap with tail</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">myPred</span><span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">myPred</span><span class="o">.</span><span class="na">prev</span> <span class="o">==</span> <span class="n">AVAILABLE</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">//If predecessor absent or released, we are done</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">now</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">now</span><span class="o">()-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//Keep trying for a while...</span>
                <span class="n">Qnode</span> <span class="n">predPred</span> <span class="o">=</span> <span class="n">myPred</span><span class="o">.</span><span class="na">prev</span><span class="o">;</span> <span class="c1">//Spin on predecessor’s prev field</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">predPred</span> <span class="o">==</span> <span class="n">AVAILABLE</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//Predecessor released lock</span>
                        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">predPred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">myPred</span> <span class="o">=</span> <span class="n">predPred</span><span class="o">;</span> <span class="c1">//Predecessor aborted, advance one</span>
        <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">tail</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">,</span> <span class="n">myPred</span><span class="o">))</span>
        <span class="n">qnode</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">myPred</span><span class="o">;</span> <span class="c1">//Do I have a successor? If CAS fails: I do have a successor, tell it about myPred (see note below)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//If CAS succeeds: no successor, simply return false. Redirecting to predecessor tells the successors that node belongs to aborted lock() request and that they must spin on its predecessor.</span>

<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>Note: In case a node is timing out it first checks if tail points to its node, if the CAS is putting back the original value, or the next value in line if you have followed any aborted nodes (i.e., the original node you were spinning on aborted, so you moved to the next in line). If the CAS fails to put back in tail the original node, then someone arrived after you, so you mark your <tt class="docutils literal"><span class="pre">prev</span></tt> pointer to the prior previous owner. If someone is spinning on your node, they will see the pointer change and follow that chain.</p>
<p>The unlock function looks like this: try to swap back in Null to the tail. If it succeeds, then you are done. Otherwise, you need to set the available to`` prev``. This change of <tt class="docutils literal"><span class="pre">prev</span></tt> signals anyone spinning on your node that they have the lock. If the <tt class="docutils literal"><span class="pre">CAS()</span></tt> fails, the condition is true, there is a successor and so I must notify it what to wait on since I am timing out. If the tail points to me, then no one is waiting and putting a null completes the <tt class="docutils literal"><span class="pre">unlock()</span></tt>.</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Qnode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="n">myNode</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">tail</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="c1">//If CAS failed: exists a successor, notify successor it can enter; if CAS successful: set tail to null, no clean up since no successor waiting</span>
                <span class="n">qnode</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">AVAILABLE</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>In this module we saw a variety of spin locks that vary in characteristics and performance. Such a variety is useful, because no single algorithm is ideal for all applications. For some applications, complex algorithms work best, and for others, simple algorithms are preferable. The best choice usually depends on specific aspects of the application and the target architecture.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/CSInParallel200wide.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">A Second Helping of Soup</a><ul>
<li><a class="reference internal" href="#the-clh-lock">The CLH Lock</a></li>
<li><a class="reference internal" href="#mcs-lock">MCS Lock</a></li>
<li><a class="reference internal" href="#a-final-real-world-complication-aborting-threads">A Final Real-World Complication: Aborting Threads</a></li>
<li><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../part2/backoffandqueue.html"
                        title="previous chapter">Solving the Mystery and Using Our Findings</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../part2/backoffandqueue.html" title="Solving the Mystery and Using Our Findings"
             >previous</a> |</li>
        <li><a href="../index.html">Spinlocks and Contention</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>