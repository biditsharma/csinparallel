<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Part Two: A Couple of Other Ideas &mdash; Spinlocks and Contention</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Spinlocks and Contention" href="../index.html" />
    <link rel="next" title="Getting More Sophisticated" href="../part3/part3.html" />
    <link rel="prev" title="MIMD, TTAS, and Other Alphabet Soup" href="../part1/alphabetsoup.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../part3/part3.html" title="Getting More Sophisticated"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../part1/alphabetsoup.html" title="MIMD, TTAS, and Other Alphabet Soup"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Spinlocks and Contention</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="part-two-a-couple-of-other-ideas">
<h1>Part Two: A Couple of Other Ideas<a class="headerlink" href="#part-two-a-couple-of-other-ideas" title="Permalink to this headline">¶</a></h1>
<div class="section" id="backoff-locks">
<h2>Backoff Locks<a class="headerlink" href="#backoff-locks" title="Permalink to this headline">¶</a></h2>
<p>To motivate an improvement on the TTAS lock algorithm, we review how it works: test the lock until it appears to be free, then pouncing with TAS. It seems logical to conclude that if another thread manages to acquire the lock between those two steps that it is under high contention and therefore unwise to continue trying to acquire immediately. Instead, it makes more sense to <em>back off</em> for some period of time.</p>
<a class="reference internal image-reference" href="../_images/backoff1.png"><img alt="Length of backoff." class="align-center" src="../_images/backoff1.png" style="width: 318.0px; height: 118.8px;" /></a>
<p>For how long should the thread back off before retrying? A good rule of thumb is that the larger the number of unsuccessful tries, the higher the likely contention, and the longer the thread should back off. Here is a simple approach. Whenever the thread sees the lock has become free but fails to acquire it, it backs off before retrying. To ensure that concurrent conflicting threads do not fall into &#8220;lockstep&#8221;, all trying to acquire the lock at the same time, the thread backs off for a random duration. Each time the thread tries and fails to get the lock, it doubles the expected time it backs off, up to a fixed maximum.</p>
<a class="reference internal image-reference" href="../_images/backoff2.png"><img alt="Length of backoff." class="align-center" src="../_images/backoff2.png" style="width: 315.6px; height: 127.2px;" /></a>
<p>Here is an implementation of such a lock. The constant MIN_DELAY indicates the initial, shortest limit (it makes no sense for the thread to back off for too short a duration).</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Backoff</span> <span class="kd">implements</span> <span class="n">lock</span> <span class="o">{</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">MIN_DELAY</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">get</span><span class="o">())</span> <span class="o">{}</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">lock</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="kc">true</span><span class="o">))</span>
                        <span class="k">return</span><span class="o">;</span>
                <span class="n">sleep</span><span class="o">(</span><span class="n">random</span><span class="o">()</span> <span class="o">%</span> <span class="n">delay</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">delay</span> <span class="o">&lt;</span> <span class="n">MAX_DELAY</span><span class="o">)</span>
                        <span class="n">delay</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">delay</span><span class="o">;</span>
                <span class="o">}</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>As in the TTAS algorithm, the thread spins testing the lock until the lock appears to be free. Then the thread tries to acquire the lock. If it fails, then it computes a random delay between zero and the current limit and then sleeps for that delay before retrying.</p>
<p>It doubles the limit for the next back-off, up to MAX_DELAY. It is important to note that the thread backs off only when it fails to acquire a lock that it had immediately before observed to be free. Observing that the lock is held by another thread says nothing about the level of contention.</p>
<p>The graph below shows that the backoff lock outperforms the TTAS lock, though it is far from the ideal curve (which is flat). The slope of the backoff curve varies greatly from one machine to another, but is invariably better than that of a TTAS lock.</p>
<a class="reference internal image-reference" href="../_images/backofftiming.png"><img alt="Length of backoff." class="align-center" src="../_images/backofftiming.png" style="width: 252.8px; height: 144.0px;" /></a>
<p>The backoff lock is easy to implement, and on many architectures performs significantly better than TTAS lock. Unfortunately, its performance is sensitive to the choice of minimum and maximum delay constants. To deploy this lock on a particular architecture, it is easy to experiment with different values, and choose the ones that work best. Experience shows, however, that these optimal values are sensitive to the number of processors and their speed, so it is not easy to tune the back-off lock class to be portable across a range of different machines.</p>
</div>
<div class="section" id="queue-locks">
<h2>Queue Locks<a class="headerlink" href="#queue-locks" title="Permalink to this headline">¶</a></h2>
<p>We now explore a different approach to implementing spin locks, one that is a little more complicated than backoff locks, but inherently more portable. One can overcome these drawbacks by having threads form a line, or queue. In a queue, each thread can learn if its turn has arrived by checking whether its predecessor has been served. Invalidation traffic is reduced by having each thread spin on a different location. A queue also allows for better utilization of the critical section since there is no need to guess when to attempt to access it: each thread is notified directly by its predecessor in the queue. Finally, a queue provides first-come-first-served fairness, the same high level of fairness achieved by the <a class="reference external" href="http://en.wikipedia.org/wiki/Lamport's_bakery_algorithm#Algorithm">bakery</a> algorithm. We now explore different ways to implement queue locks, a family of locking algorithms that exploit these insights.</p>
<p>Here is the Anderson queue lock, a simple array-based queue lock. The threads share an atomic integer tail field, initially zero. To acquire the lock, each thread atomically increments the tail field. Call the resulting value the thread&#8217;s slot. The slot is used as an index into a Boolean flag array. If <tt class="docutils literal"><span class="pre">flag[j]</span></tt> is true, then the thread with slotj has permission to acquire the lock. Initially, <tt class="docutils literal"><span class="pre">flag[0]</span></tt> is true.</p>
<a class="reference internal image-reference" href="../_images/andlock1.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock1.png" style="width: 288.8px; height: 137.6px;" /></a>
<p>To acquire the lock, each thread atomically increments the tail field. We&#8217;ll call the resulting value the thread&#8217;s slot.</p>
<a class="reference internal image-reference" href="../_images/andlock2.png"><img alt="Timing of queue lock." class="align-left" src="../_images/andlock2.png" style="width: 288.8px; height: 137.6px;" /></a>
<a class="reference internal image-reference" href="../_images/andlock3.png"><img alt="Timing of queue lock." class="align-right" src="../_images/andlock3.png" style="width: 276.8px; height: 132.0px;" /></a>
<a class="reference internal image-reference" href="../_images/placeholder.png"><img alt="../_images/placeholder.png" class="align-center" src="../_images/placeholder.png" style="width: 86.0px; height: 16.0px;" /></a>
<p>The slot is used as an index into a Boolean flag array. If <tt class="docutils literal"><span class="pre">flag[j]</span></tt> is true, then the thread with slot <em>j</em> has permission to acquire the lock. Initially, <tt class="docutils literal"><span class="pre">flag[0]</span></tt> is true. To acquire the lock, a thread spins until the flag at its slot becomes true.</p>
<a class="reference internal image-reference" href="../_images/andlock4.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock4.png" style="width: 272.0px; height: 136.0px;" /></a>
<p>Here another thread wants to acquire the lock.</p>
<a class="reference internal image-reference" href="../_images/andlock5.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock5.png" style="width: 270.4px; height: 136.8px;" /></a>
<p>It applies get-and-increment to the next pointer...</p>
<a class="reference internal image-reference" href="../_images/andlock6.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock6.png" style="width: 278.4px; height: 139.2px;" /></a>
<p>...and advances the next pointer to acquire its own slot.</p>
<a class="reference internal image-reference" href="../_images/andlock7.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock7.png" style="width: 278.4px; height: 143.2px;" /></a>
<p>Then it spins until the flag variable at that slot becomes true.</p>
<a class="reference internal image-reference" href="../_images/andlock8.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock8.png" style="width: 271.2px; height: 152.0px;" /></a>
<p>The first thread releases the lock by setting the next slot to true.</p>
<a class="reference internal image-reference" href="../_images/andlock9.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock9.png" style="width: 269.6px; height: 140.0px;" /></a>
<p>The second thread notices the change, and enters its critical section.</p>
<a class="reference internal image-reference" href="../_images/andlock10.png"><img alt="Timing of queue lock." class="align-center" src="../_images/andlock10.png" style="width: 292.0px; height: 134.4px;" /></a>
<p>Here is an implementation of the Anderson queue lock.</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ALock</span> <span class="kd">implements</span> <span class="n">Lock</span> <span class="o">{</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">flags</span><span class="o">=</span> <span class="o">{</span><span class="kc">true</span><span class="o">,</span><span class="kc">false</span><span class="o">,...,</span><span class="kc">false</span><span class="o">};</span> <span class="c1">//one flag per thread</span>
        <span class="n">AtomicInteger</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">//next field tells us which flag to use</span>
        <span class="c1">//each thread has a thread-local variable that keeps track of its slot</span>
        <span class="c1">//(that is, each thread has a private instance of mySlot</span>
        <span class="c1">//shared only by name and not reference)</span>
        <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">mySlot</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>We have one flag per thread, which means we have to know how many threads there are - there are <em>N</em> flags because you never expect to see more than <em>N</em> threads (each in line waiting for the lock). Unlike the <a class="reference external" href="http://en.wikipedia.org/wiki/Lamport's_bakery_algorithm#Algorithm">bakery</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/Peterson's_algorithm#Filter_algorithm:_Peterson.27s_algorithm_for_N_processes">Peterson filter</a> algorithms, the flags are multi-reader and multi-writer, so a thread does not have an exclusive location in the flag array. Rather, a thread calls get-and-increment to get an assigned slot. It then spins on its assigned slot until the value is true.</p>
<p>Bus traffic, then, is greatly reduced as each thread spins on a locally cached copy of a single array location - contention on the flags is minimized and invalidation traffic is low as well. However, contention may still occur due to <em>false sharing</em>: cache memory is not stored as individual items but as multiword lines, and adjacent data items like array elements frequently share lines. When one flag is changed, it will invalidate its entire cache line, which may include nearby unchanged items. One way around this problem is to <em>pad</em> array elements so that each element is mapped to a distinct cache line (for example, with a cache of four-word lines, we can increase the lock array size fourfold and moving from location <em>i</em> to next location 4(<em>i</em> + 1) mod 32 rather than <em>i</em> + 1 mod 8.</p>
<p>Here is the code for the lock and unlock methods: if I&#8217;m a thread, first, I claim a slot by atomically incrementing the next field. Next, I wait until my predecessor has released the lock. I reset my slot to false so that it can be used the next time around. To release the lock, I set the slot after mine to true, being careful to wrap around.</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">mySlot</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">();</span> <span class="c1">//take next slot</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">flags</span><span class="o">[</span><span class="n">mySlot</span> <span class="o">%</span> <span class="n">n</span><span class="o">])</span> <span class="o">{};</span> <span class="c1">//spin until told where to go</span>
        <span class="n">flags</span><span class="o">[</span><span class="n">mySlot</span> <span class="o">%</span> <span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//prepare slot for reuse</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">flags</span><span class="o">[(</span><span class="n">mySlot</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">//tell next thread to go</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>The Anderson queue lock improves on backoff locks because it reduces invalidations to a minimum and schedules access to the critical section tightly, minimizing the interval between when a lock is freed by one thread and when is acquired by another. There is also a theoretical benefit: unlike the TTAS and backoff lock, this algorithm guarantees that there is no lockout, and in fact, provides first-come-first-served fairness, which we actually lose in TTAS and TTAS with backoff.</p>
<a class="reference internal image-reference" href="../_images/queuegraph.png"><img alt="Timing of queue lock." class="align-center" src="../_images/queuegraph.png" style="width: 167.0px; height: 130.0px;" /></a>
<p>The Anderson lock is the first truly scalable lock we&#8217;ve examined so far, and is simple and easy to implement. However, the Anderson lock has two disadvantages. First, it is not space-efficient; it requires knowing a bound <em>N</em> on the maximum number of concurrent threads, and it allocates an array of that size per lock (one bit per thread). Thus, <em>L</em> locks will require <em>O(LN)</em> space even if a thread accesses only one lock at a given time. Second, the lock is poorly suited for uncached architectures, since any thread may end up spinning on any array location, and in the absence of caches, spinning on a remote location may be very expensive.</p>
</div>
<div class="section" id="the-clh-lock">
<h2>The CLH Lock<a class="headerlink" href="#the-clh-lock" title="Permalink to this headline">¶</a></h2>
<p>The CLH queue lock (by Travis Craig, Anders Landin, and Erik Hagersten - most of these algorithms are named for their creators) is much more space-efficient, since it incurs a small constant-size overhead per thread. It also provides FIFO fairness.</p>
<p>This algorithm records each thread&#8217;s status in a QNode object, which has a Boolean locked field. If that field is true, then the corresponding thread either has acquired the lock or is waiting for the lock. If that field is false, then the thread has released the lock.  The lock itself is represented as a virtual linked list of QNodes objects. We use the term &#8220;virtual&#8221; because the list is implicit: each thread points to its predecessor through a thread-local <tt class="docutils literal"><span class="pre">predvariable</span></tt>. The public tail variable points to the last node in the queue.</p>
<a class="reference internal image-reference" href="../_images/clh1to3.png"><img alt="CLH" class="align-center" src="../_images/clh1to3.png" style="width: 606.0px; height: 172.8px;" /></a>
<p>To acquire the lock, a thread sets the locked field of its QNode to true, meaning that the thread is not ready to release the lock.</p>
<a class="reference internal image-reference" href="../_images/clh4.png"><img alt="CLH" class="align-center" src="../_images/clh4.png" style="width: 168.8px; height: 148.0px;" /></a>
<p>The thread applies swap to the tail to make its own node the tail of the queue, simultaneously acquiring a reference to its predecessor&#8217;s QNode.</p>
<a class="reference internal image-reference" href="../_images/clh5.png"><img alt="CLH" class="align-center" src="../_images/clh5.png" style="width: 187.2px; height: 150.4px;" /></a>
<p>Because it sees that its predecessor’s QNode is false, this thread now has the lock.</p>
<a class="reference internal image-reference" href="../_images/clh6.png"><img alt="CLH" class="align-center" src="../_images/clh6.png" style="width: 171.2px; height: 172.8px;" /></a>
<p>Another thread that wants the lock does the same sequence of steps …</p>
<a class="reference internal image-reference" href="../_images/clh7.png"><img alt="CLH" class="align-left" src="../_images/clh7.png" style="width: 255.2px; height: 168.8px;" /></a>
<a class="reference internal image-reference" href="../_images/clh8.png"><img alt="CLH" class="align-right" src="../_images/clh8.png" style="width: 270.4px; height: 151.2px;" /></a>
<p>Note that the list is ordered implicitly - there are no real pointers between the nodes.</p>
<a class="reference internal image-reference" href="../_images/clh9.png"><img alt="CLH" class="align-center" src="../_images/clh9.png" style="width: 236.8px; height: 140.8px;" /></a>
<p>But each thread keeps a reference of the node it added to the list. So each thread has the node it was assigned from the swap and the reference to the node it added when the swap completed.</p>
<a class="reference internal image-reference" href="../_images/clh10.png"><img alt="CLH" class="align-center" src="../_images/clh10.png" style="width: 231.2px; height: 183.2px;" /></a>
<p>Again, the links are implicit, as shown below.</p>
<a class="reference internal image-reference" href="../_images/clh11.png"><img alt="CLH" class="align-center" src="../_images/clh11.png" style="width: 301.6px; height: 177.6px;" /></a>
<p>The waiting thread then spins on its predecessor&#8217;s QNode until the predecessor releases the lock.</p>
<a class="reference internal image-reference" href="../_images/clh12.png"><img alt="CLH" class="align-center" src="../_images/clh12.png" style="width: 232.0px; height: 194.4px;" /></a>
<p>The thread actually spins on a <em>cached</em> copy of purple&#8217;s node. This is very efficient in terms of interconnect traffic (unless you are on a NUMA architecture, where purple&#8217;s node may be on a different processor).</p>
<a class="reference internal image-reference" href="../_images/clh13.png"><img alt="CLH" class="align-center" src="../_images/clh13.png" style="width: 288.8px; height: 193.6px;" /></a>
<p>Some coherence protocols shared memory might not be updated at all, only the cached copy. This is very efficient.</p>
<a class="reference internal image-reference" href="../_images/clh14.png"><img alt="CLH" class="align-center" src="../_images/clh14.png" style="width: 296.8px; height: 176.8px;" /></a>
<p>When a thread acquires a lock it can reuse its predecessor&#8217;s QNode as its new node for future lock accesses. Note that it can do so since at this point the thread&#8217;s predecessor&#8217;s QNode will no longer be used by the predecessor, and the thread&#8217;s old QNode is pointed to either by the thread&#8217;s successor or by the tail.</p>
<a class="reference internal image-reference" href="../_images/clh15.png"><img alt="CLH" class="align-center" src="../_images/clh15.png" style="width: 231.2px; height: 179.2px;" /></a>
<p>The reuse of the QNode&#8217;s means that for <em>L</em> locks and <em>N</em> threads, if each thread accesses at most one lock at a time, we only need O(<em>L</em>+<em>N</em>) space as compared with  O(<em>LN</em>) for the ALock. Of course, this only holds for accessing one lock at a time. If you access all <em>L</em> locks, then you need a QNode for each access.</p>
<p>Here is what the code looks like as a Java object: if the locked field is true, the lock has not been released yet (it may also not have been acquired yet either).</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">Qnode</span> <span class="o">{</span>
        <span class="n">AtomicBoolean</span> <span class="n">locked</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>And here is the code for the lock:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">CLHLock</span> <span class="kd">implements</span> <span class="n">Lock</span> <span class="o">{</span>
        <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Qnode</span><span class="o">&gt;</span> <span class="n">tail</span><span class="o">;</span> <span class="c1">//tail of the queue</span>
        <span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">Qnode</span><span class="o">&gt;</span> <span class="n">myNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Qnode</span><span class="o">();</span>
        <span class="c1">//recall that ThreadLocal means that each thread has a private</span>
        <span class="c1">//instance of myNode, shared only by name and not reference)</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">Qnode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">myNode</span><span class="o">);</span> <span class="c1">//swap in myNode</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">pred</span><span class="o">.</span><span class="na">locked</span><span class="o">)</span> <span class="o">{}</span> <span class="c1">//spin until predecessor releases lock</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">myNode</span><span class="o">.</span><span class="na">locked</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span> <span class="c1">//notify successor</span>
                <span class="n">myNode</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span> <span class="c1">//recycle predecessor&#39;s node</span>
                <span class="c1">//(notice that we don&#39;t actually reuse myNode in lock())</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>Like the ALock, this algorithm has each thread spin on a distinct location, so when one thread releases its lock, it invalidates its successor&#8217;s cache only, and does not invalidate any other thread&#8217;s cache. It does so with a lower space overhead, and, importantly, without requiring prior knowledge of the number of threads accessing a lock. It also provides first-come-first-served fairness.</p>
<p>To understand the principal disadvantage of this lock algorithm, we need to know a little more about non-uniform memory (NUMA) architectures. NUMA architectures tend to be described as if they have flat shared memory, but the truth is that not all have caches, and some regions of memory are faster than others. The principal disadvantage of the CLHLock algorithm is that it performs poorly on cacheless NUMA architectures -   each thread spins waiting for its predecessors&#8217; nodes to become false. If this memory location is remote, then performance will suffer.</p>
<a class="reference internal image-reference" href="../_images/numatiming.png"><img alt="CLH" class="align-center" src="../_images/numatiming.png" style="width: 375.2px; height: 192.8px;" /></a>
<p>On cache-coherent architectures, however, this approach should work well.</p>
</div>
<div class="section" id="mcs-lock">
<h2>MCS Lock<a class="headerlink" href="#mcs-lock" title="Permalink to this headline">¶</a></h2>
<p>The MCS lock is another kind of queue lock that ensures that processes always spin on a fixed location in local memory, so this one works well for cacheless architectures. Like the CLH lock, it uses only a small fixed-size overhead per thread. It also provides FIFO fairness.</p>
<p>Here, too, the lock is represented as a linked list of QNodes, where each QNode represents either a lock holder or a thread waiting to acquire the lock. Unlike the CLH lock, the list is explicit, not virtual.</p>
<a class="reference internal image-reference" href="../_images/mcs1.png"><img alt="MCS" class="align-center" src="../_images/mcs1.png" style="width: 169.6px; height: 144.0px;" /></a>
<p>To acquire the lock, a thread places its own QNode at the tail of the list.</p>
<a class="reference internal image-reference" href="../_images/mcs2.png"><img alt="MCS" class="align-center" src="../_images/mcs2.png" style="width: 264.8px; height: 141.6px;" /></a>
<p>The node then swaps in a reference to its own QNode.</p>
<a class="reference internal image-reference" href="../_images/mcs3.png"><img alt="MCS" class="align-center" src="../_images/mcs3.png" style="width: 271.2px; height: 142.4px;" /></a>
<p>At this point the swap is completed, and the queue variable points to the tail of the queue.</p>
<a class="reference internal image-reference" href="../_images/mcs4.png"><img alt="MCS" class="align-center" src="../_images/mcs4.png" style="width: 260.8px; height: 160.8px;" /></a>
<p>To acquire the lock, a thread places its own QNode at the tail of the list. If there are no other QNodes on the list, it looks like this.</p>
<a class="reference internal image-reference" href="../_images/mcs5.png"><img alt="MCS" class="align-center" src="../_images/mcs5.png" style="width: 264.0px; height: 156.8px;" /></a>
<p>If a thread trying to acquire the lock has a predecessor, it modifies the predecessor&#8217;s node to refer back to its own QNode.</p>
<a class="reference internal image-reference" href="../_images/mcs6to7.png"><img alt="MCS" class="align-center" src="../_images/mcs6to7.png" style="width: 616.0px; height: 176.0px;" /></a>
<p>The predecessor&#8217;s node now refers to the red processor&#8217;s QNode.</p>
<a class="reference internal image-reference" href="../_images/mcs8.png"><img alt="MCS" class="align-center" src="../_images/mcs8.png" style="width: 294.4px; height: 156.8px;" /></a>
<p>The red processor now spins locally, waiting for its turn.</p>
<a class="reference internal image-reference" href="../_images/mcs9.png"><img alt="MCS" class="align-center" src="../_images/mcs9.png" style="width: 291.2px; height: 176.0px;" /></a>
<p>The purple node is the first node, and it finds the lock free, so its flag is already set to true (default on creation).</p>
<a class="reference internal image-reference" href="../_images/mcs10.png"><img alt="MCS" class="align-center" src="../_images/mcs10.png" style="width: 291.2px; height: 173.6px;" /></a>
<p>The red processor acquires the lock!</p>
<a class="reference internal image-reference" href="../_images/mcs11.png"><img alt="MCS" class="align-center" src="../_images/mcs11.png" style="width: 295.2px; height: 152.8px;" /></a>
<p>So now that we understand how it works, let&#8217;s take a look at the code. Here is the code for QNodes:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">Qnode</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">Qnode</span> <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>And here is the code that uses the QNode to implement an MCSLock:</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">class</span> <span class="nc">MCSLock</span> <span class="kd">implements</span> <span class="n">Lock</span> <span class="o">{</span>
        <span class="n">AtomicReference</span> <span class="n">tail</span><span class="o">;</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
                <span class="n">Qnode</span> <span class="n">qnode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Qnode</span><span class="o">();</span> <span class="c1">//qnode should be a thread-local variable!</span>
                <span class="c1">//we&#39;ll need it in the unlock method.</span>
                <span class="n">Qnode</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="n">qnode</span><span class="o">);</span> <span class="c1">//add my node to the tail of queue</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">qnode</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">qnode</span><span class="o">;</span>
                        <span class="k">while</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">locked</span><span class="o">)</span> <span class="o">{}</span> <span class="c1">//wait until unlocked</span>
                <span class="o">}</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>The only way the CAS will fail is if someone has changed the tail. The fact that the tail has now changed suggests that someone else is trying to acquire the lock, and we need to wait for them to set the next pointer.</p>
<div class="highlight-java"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">//no successor?</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">CAS</span><span class="o">(</span><span class="n">qnode</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> <span class="c1">//if really no successor, return</span>
                <span class="k">return</span><span class="o">;</span>
                <span class="k">while</span> <span class="o">(</span><span class="n">qnode</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{}</span> <span class="c1">//Otherwise wait for successor to catch up</span>
                <span class="o">}</span>
        <span class="n">qnode</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//pass lock to successor</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table></div>
<p>We&#8217;ll unpack unlocking with some more images. We left off here:</p>
<a class="reference internal image-reference" href="../_images/mcsunlock1.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock1.png" style="width: 265.6px; height: 134.4px;" /></a>
<p>The purple node looks at the queue.</p>
<a class="reference internal image-reference" href="../_images/mcsunlock2.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock2.png" style="width: 265.6px; height: 175.2px;" /></a>
<p>Red prepares to spin...</p>
<a class="reference internal image-reference" href="../_images/mcsunlock3.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock3.png" style="width: 263.2px; height: 140.0px;" /></a>
<a class="reference internal image-reference" href="../_images/mcsunlock4.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock4.png" style="width: 264.8px; height: 138.4px;" /></a>
<p>...and then spins!</p>
<a class="reference internal image-reference" href="../_images/mcsunlock5.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock5.png" style="width: 264.8px; height: 142.4px;" /></a>
<p>And red has acquired the lock!</p>
<a class="reference internal image-reference" href="../_images/mcsunlock6.png"><img alt="MCS" class="align-center" src="../_images/mcsunlock6.png" style="width: 264.8px; height: 142.4px;" /></a>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/CSInParallel200wide.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Part Two: A Couple of Other Ideas</a><ul>
<li><a class="reference internal" href="#backoff-locks">Backoff Locks</a></li>
<li><a class="reference internal" href="#queue-locks">Queue Locks</a></li>
<li><a class="reference internal" href="#the-clh-lock">The CLH Lock</a></li>
<li><a class="reference internal" href="#mcs-lock">MCS Lock</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../part1/alphabetsoup.html"
                        title="previous chapter">MIMD, TTAS, and Other Alphabet Soup</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../part3/part3.html"
                        title="next chapter">Getting More Sophisticated</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../part3/part3.html" title="Getting More Sophisticated"
             >next</a> |</li>
        <li class="right" >
          <a href="../part1/alphabetsoup.html" title="MIMD, TTAS, and Other Alphabet Soup"
             >previous</a> |</li>
        <li><a href="../index.html">Spinlocks and Contention</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>