<html><head><title>OpenMP timing on MTL and scalability</title><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');ol{margin:0;padding:0}.c8{color:#444477;font-size:12pt;background-color:#ffffff;font-weight:bold}.c11{font-size:10pt;font-style:italic;font-family:"Courier New"}.c24{color:#000055;font-size:12pt;background-color:#ffffff}.c22{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c15{color:#0077ff;font-size:12pt;background-color:#ffffff}.c21{color:#227777;font-size:12pt;background-color:#ffffee}.c13{color:#bb6666;font-size:12pt;background-color:#ffeeff}.c23{color:#994444;font-size:12pt;background-color:#ffffee}.c18{color:#ff9999;font-size:12pt;background-color:#ffffff}.c5{color:#000044;font-size:12pt;background-color:#ffffff}.c2{color:#111122;font-size:12pt;background-color:#ffffff}.c12{font-size:10pt;font-family:"Courier New"}.c6{font-size:12pt;font-family:"Courier New"}.c1{font-size:12pt;font-family:"Times New Roman"}.c0{direction:ltr;margin-left:36pt}.c3{height:11pt;direction:ltr}.c10{margin-left:35pt}.c17{font-style:italic}.c7{font-family:"Consolas"}.c9{font-family:"Times New Roman"}.c16{font-weight:bold}.c20{vertical-align:super}.c14{height:11pt}.c19{font-size:18pt}.c4{direction:ltr}.title{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:36pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:"Georgia";padding-bottom:4pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:24pt;line-height:1.15;text-align:left;color:#000000;font-size:24pt;font-family:"Arial";font-weight:bold;padding-bottom:6pt}h2{padding-top:18pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h3{padding-top:14pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";font-weight:bold;padding-bottom:4pt}h4{padding-top:12pt;line-height:1.15;text-align:left;color:#000000;font-size:12pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h5{padding-top:11pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}h6{padding-top:10pt;line-height:1.15;text-align:left;color:#000000;font-size:10pt;font-family:"Arial";font-weight:bold;padding-bottom:2pt}</style></head><body class="c22"><p class="c4"><span class="c9 c16 c19">Using OpenMP: Timing and Performance on Intel Manycore testing lab</span></p><p class="c3"><span class="c9 c16 c19"></span></p><p class="c4"><span class="c9 c16 c19">Timing performance</span></p><p class="c4"><span class="c1">We would like to know how long it takes to run various versions of our programs so that we can determine if adding additional threads to our computation is worth it. &nbsp;</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">There are several different ways that we can obtain the time it takes a program to run (we typically like to get this time in milliseconds or less).</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1 c16">1. Simple, less accurate way:</span><span class="c1">&nbsp;</span><span class="c1">We can obtain the running time for an entire program using the </span><span class="c6">time</span><span class="c1">&nbsp;Linux program. For example, the line</span></p><p class="c3"><span class="c1"></span></p><p class="c10 c4"><span class="c12">/usr/bin/time -p trap-omp</span></p><p class="c3 c10"><span class="c1"></span></p><p class="c4"><span class="c1">might display the following output:</span></p><p class="c10 c4"><span class="c12">OMP defined, threadct = 1</span></p><p class="c10 c4"><span class="c12">With n = 1048576 trapezoids, our estimate of the integral from 0 to 3.14159 is 2</span></p><p class="c10 c4"><span class="c12">real 0.04</span></p><p class="c10 c4"><span class="c12">user 0.04</span></p><p class="c10 c4"><span class="c12">sys 0.00</span></p><p class="c3 c10"><span class="c12"></span></p><p class="c4"><span class="c1">Here, we use the full path </span><span class="c6">/usr/bin/time</span><span class="c1">&nbsp;to insure that we are accessing the time </span><span class="c1 c17">program</span><span class="c1">&nbsp;instead of a shell built-in command. The </span><span class="c6">-p</span><span class="c1">&nbsp;flag produces output in a format comparable to what we will see in the MTL.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">The </span><span class="c6">real</span><span class="c1">&nbsp;time measures actual time elapsed during the running of your command </span><span class="c6">trap-omp</span><span class="c1">. </span><span class="c6">user</span><span class="c1">&nbsp;measures the amount of time executing user code, and </span><span class="c6">sys</span><span class="c1">&nbsp;measures the time executing in Linux kernel code.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">Try the time command using your linux </span><span class="c1">machine</span><span class="c1">, and compare the results for different thread counts. You should find that real time decreases somewhat when changing from 1 thread to 2 threads; user time increases somewhat. Can you think of reasons that might produce these results?</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">Also, real time and user time increase considerably on some machines when increasing from 2 to 3 or more threads. What might explain that?</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1 c16">2. &nbsp;Using OpenMP functions for timing code: </span><span class="c9">The for loop in your trap-omp.C code represents the parallel portion of the code. &nbsp;The other parts are the &lsquo;sequential parts&rsquo; where one thread is being used. &nbsp;Using functions to get current time at points in your program, you can begin to examine how long the sequential port takes in relation to the parallel portion. &nbsp;You can also use these functions around all the code to determine how long it takes.</span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c9">We can use an OMP library function whose &lsquo;signature&rsquo; looks like this:</span></p><p class="c0"><span class="c9">#include &lt;omp.h&gt;</span></p><p class="c0"><span class="c9">double omp_get_wtime( void );</span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c9">We can use this in the code in the following way:</span></p><p class="c0"><span class="c7">// Starting the time measurement</span></p><p class="c0"><span class="c7">double start = omp_get_wtime();</span></p><p class="c0"><span class="c7">// Computations to be measured</span></p><p class="c0"><span class="c7">...</span></p><p class="c0"><span class="c7">// Measuring the elapsed time</span></p><p class="c0"><span class="c7">double end = omp_get_wtime();</span></p><p class="c0"><span class="c7">// Time calculation (in seconds)</span></p><p class="c0"><span class="c7">double time1 = end - start;</span></p><p class="c0 c14"><span class="c7"></span></p><p class="c0"><span class="c7">//print out the resulting elapsed time</span></p><p class="c0"><span class="c7">...</span></p><p class="c0"><span class="c7">}</span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c1">Try inserting this code and printing out the time it takes to execute portions of your trap-omp.C code. &nbsp;You will use this for later portions of this activity.</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1 c16">3. You could use basic linux/C/C++ timing functions: </span><span class="c1">See the end of this activity for an explanation of the way in which we can time any C/C++ code, even if you are not using OpenMP library functions or pragmas.</span></p><h2 class="c4"><span class="c9 c16 c19">Using the MTL</span></h2><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">Let&rsquo;s try using many more threads and really experiment with multicore programming! </span><span class="c1">You will need to use a &lsquo;terminal&rsquo; on Macs or &lsquo;Putty&rsquo; on PCs. &nbsp;I</span><span class="c1">f you are off campus, you will want to log into selkie before then logging into the MTL machine at Intel&rsquo;s headquarters in Oregon. &nbsp;</span><span class="c1">You can login to the MTL computer, as follows</span></p><p class="c3"><span class="c1"></span></p><p class="c10 c4"><span class="c12">&nbsp;ssh </span><span class="c11">accountname</span><span class="c12">@192.55.51.81</span></p><p class="c3 c10"><span class="c1"></span></p><p class="c10 c4"><span class="c1">Use one of the student account usernames </span><span class="c6">provided to you</span><span class="c1">, together with the password distributed to the class.</span></p><p class="c3 c10"><span class="c1"></span></p><p class="c4"><span class="c1">Next, copy your program from your laptop or selkie to the MTL machine. One way to do this is to logout (or preferably use another window to keep for copying your code), then enter the following command:</span></p><p class="c3"><span class="c1"></span></p><p class="c10 c4"><span class="c12">&nbsp;scp trap-omp.C </span><span class="c11">accountname</span><span class="c12">@192.55.51.81:</span></p><p class="c3 c10"><span class="c1"></span></p><p class="c4"><span class="c1">After making this copy, login into the MTL machine </span><span class="c12">192.55.51.81</span><span class="c1">&nbsp;again.</span></p><p class="c3 c10"><span class="c1"></span></p><p class="c4"><span class="c1">On the MTL machine, compile and test run your program.</span></p><p class="c3"><span class="c1"></span></p><p class="c10 c4"><span class="c12">&nbsp;g++ -o trap-omp trap-omp.C -lm -fopenmp</span></p><p class="c10 c4"><span class="c12">&nbsp;./trap-omp</span></p><p class="c10 c4"><span class="c12">&nbsp;./trap-omp 2</span></p><p class="c10 c4"><span class="c12">&nbsp;./trap-omp 16</span></p><p class="c10 c4"><span class="c1 c17">Note:</span><span class="c1">&nbsp;Since the current directory </span><span class="c6">.</span><span class="c1">&nbsp;may not be in your default path, you probably need to use the path name </span><span class="c6">./trap-omp</span><span class="c1">&nbsp;to invoke your program.</span></p><p class="c3 c10"><span class="c1"></span></p><p class="c4"><span class="c1">Now, try some time trials of your code on the MTL machine. (The full pathname for </span><span class="c6">time</span><span class="c1">&nbsp;and the </span><span class="c6">-p</span><span class="c1">&nbsp;flag are unnecessary.) For example, using </span><span class="c1 c17">time</span><span class="c1">:</span></p><p class="c3"><span class="c1"></span></p><p class="c10 c4"><span class="c12">&nbsp;time trap-omp</span></p><p class="c10 c4"><span class="c12">&nbsp;time trap-omp 2</span></p><p class="c10 c4"><span class="c12">&nbsp;time trap-omp 3</span></p><p class="c10 c4"><span class="c12">&nbsp;time trap-omp 4</span></p><p class="c10 c4"><span class="c12">&nbsp;time trap-omp 8</span></p><p class="c10 c4"><span class="c12">&nbsp;time trap-omp 16</span></p><p class="c10 c4"><span class="c12">&nbsp;time trap-omp 32</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">What patterns do you notice with the </span><span class="c6">real</span><span class="c1">&nbsp;and </span><span class="c6">user</span><span class="c1">&nbsp;times of various runs of </span><span class="c6">trap-omp</span><span class="c1">&nbsp;with various values of </span><span class="c6">threadct</span><span class="c1">?</span></p><p class="c3"><span class="c1"></span></p><p class="c4"><span class="c1">Also try it without using the </span><span class="c1 c17">time </span><span class="c1">command on the command line and instead using the OpenMP </span><span class="c7">omp_get_wtime() </span><span class="c9">function calls in your code.</span><span class="c1">&nbsp;</span></p><p class="c3"><span class="c9"></span></p><h3 class="c4"><a name="h.pj8r9f41zcj9"></a><span>Submitting Batch Jobs for Timing Accurately</span></h3><p class="c4"><span>To submit a job on MTL and guarantee that you have exclusive access to a nod for timing purposes, you submit your job to a queuing system. &nbsp;You do this by creating a &lsquo;script&rsquo; file that will be read by the queuing system. &nbsp;Then you use the </span><span class="c17">qsub</span><span>&nbsp;command to run that script. &nbsp;Here is an example of the contents of a script file (save it as submit.sh on your MTL account):</span></p><p class="c3"><span></span></p><p class="c4"><span>#!/bin/sh </span></p><p class="c4"><span>#PBS -N LS_trap </span></p><p class="c4"><span>#PBS -j oe </span></p><p class="c3"><span></span></p><p class="c4"><span>#$HOME/240activities/trap-omp 32 10485760</span></p><p class="c4"><span>#here is how we can send parameters from job submission on the command line:</span></p><p class="c4"><span>$HOME/240activities/trap-omp $p $n</span></p><p class="c3"><span></span></p><p class="c4"><span>#the job gets submitted like this:</span></p><p class="c4"><span>#qsub -l select=1:ncpus=32 -v &#39;p=32, n=10485760&#39; /home/mcls/240activities/submit.sh</span></p><p class="c3"><span></span></p><p class="c4"><span>######### end of script file</span></p><p class="c3"><span></span></p><p class="c4"><span>Here is an example of how you run the script (change the path for your user account):</span></p><p class="c3"><span></span></p><p class="c4"><span>qsub -l select=1:ncpus=32 -v &#39;p=32, n=10485760&#39; /home/mcls/240activities/submit.sh</span></p><p class="c3"><span></span></p><p class="c3"><span></span></p><h3 class="c4"><a name="h.1f4qtn5dzzc3"></a><span>Investigating &lsquo;scalability&rsquo;</span></h3><p class="c4"><span class="c9">As you keep the same &lsquo;problem size&rsquo;, i.e. the amount of work being done, and increase the number of processors, you would hope that the time drops proportionally to the number of processors used. &nbsp;So in your case of the problem size being the number of trapezoids computed, 2</span><span class="c9 c20">20</span><span class="c9">, are you able to halve the time as you double the number of threads? &nbsp;When does this stop being the case, if at all? &nbsp;When this occurs, your program is exhibiting </span><span class="c17 c9">strong scalability, </span><span class="c9">in that additional resources (threads in this case) help you obtain an answer faster. &nbsp;To truly determine whether you have strong scalability, you will likely need to try a larger problem size on the MTL.</span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c9">An interesting set of experiments to try is to increase the problem size by changing the number of trapezoids to values higher than 2</span><span class="c9 c20">20</span><span>. </span><span class="c17 c9 c16">Try this:</span><span class="c9">&nbsp;if you double the problem size and double the number of threads, does the loop take the same amount of time? &nbsp;In high performance computation, this is known as weak scalability: &nbsp;you can keep using more processors (to a point) to tackle larger problems.</span></p><p class="c3"><span class="c9 c20"></span></p><h3 class="c4"><a name="h.385dxp19hydt"></a><span>What happens when you have more threads than cores?</span></h3><p class="c4"><span class="c9">Another interesting investigation is to consider what happens when you &lsquo;oversubscribe&rsquo; the cores by using more threads than cores available. &nbsp;Try this experiment and write down your results and try to explain them.</span></p><p class="c3"><span class="c9"></span></p><h3 class="c4"><a name="h.t5v7q2aplofu"></a><span>An Alternative Method for Timing Code (optional; for reference)</span></h3><p class="c4"><span class="c9">The following code snippets can be used in your program to time sections of your program. &nbsp;This is the traditional linux/C/C++ method, which is most likely what the implementation of the OMP function get_wtime() is using.</span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c8">/</span><span class="c13">* Put this line at the top of the file: *</span><span class="c8">/</span><span class="c2"><br></span><span class="c17 c24">#include &lt;sys/time.h&gt;</span><span class="c2"><br><br></span><span class="c8">/</span><span class="c13">* Put this right before the code you want to time: *</span><span class="c8">/</span><span class="c2"><br></span><span class="c5">struct</span><span class="c2">&nbsp;</span><span class="c5">timeval</span><span class="c2">&nbsp;</span><span class="c5">timer_start</span><span class="c8">,</span><span class="c2">&nbsp;</span><span class="c5">timer_end</span><span class="c8">;</span><span class="c2"><br></span><span class="c5">gettimeofday</span><span class="c8">(&amp;</span><span class="c5">timer_start</span><span class="c8">,</span><span class="c2">&nbsp;</span><span class="c15">NULL</span><span class="c8">);</span><span class="c2"><br><br></span><span class="c8">/</span><span class="c13">* Put this right after the code you want to time: *</span><span class="c8">/</span><span class="c2"><br></span><span class="c5">gettimeofday</span><span class="c8">(&amp;</span><span class="c5">timer_end</span><span class="c8">,</span><span class="c2">&nbsp;</span><span class="c15">NULL</span><span class="c8">);</span><span class="c2"><br></span><span class="c5">double</span><span class="c2">&nbsp;</span><span class="c5">timer_spent</span><span class="c2">&nbsp;</span><span class="c8">=</span><span class="c2">&nbsp;</span><span class="c5">timer_end</span><span class="c8">.</span><span class="c5">tv_sec</span><span class="c2">&nbsp;</span><span class="c8">-</span><span class="c2">&nbsp;</span><span class="c5">timer_start</span><span class="c8">.</span><span class="c5">tv_sec</span><span class="c2">&nbsp;</span><span class="c8">+</span><span class="c2">&nbsp;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(</span><span class="c5">timer_end</span><span class="c8">.</span><span class="c5">tv_usec</span><span class="c2">&nbsp;</span><span class="c8">-</span><span class="c2">&nbsp;</span><span class="c5">timer_start</span><span class="c8">.</span><span class="c5">tv_usec</span><span class="c8">)</span><span class="c2">&nbsp;</span><span class="c8">/</span><span class="c2">&nbsp;</span><span class="c18">1000000.0</span><span class="c8">;</span><span class="c2"><br></span><span class="c5">printf</span><span class="c8">(&quot;</span><span class="c23">Time spent: %.6f</span><span class="c21">\n</span><span class="c8">&quot;,</span><span class="c2">&nbsp;</span><span class="c5">timer_spent</span><span class="c8">);</span></p><p class="c3"><span class="c9"></span></p><p class="c4"><span class="c9">The for loop in your trap-omp.C code represents the parallel portion of the code. &nbsp;The other parts are the &lsquo;sequential parts&rsquo; where one processor, or thread is being used. &nbsp;Using the above code snippets as a guide, you can begin to examine how long the sequential port takes in relation to the parallel portion.</span></p></body></html>