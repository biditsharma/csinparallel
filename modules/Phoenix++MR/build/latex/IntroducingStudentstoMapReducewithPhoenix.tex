% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\else\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{0}


\title{Introducing Students to MapReduce with Phoenix++ Documentation}
\date{Aug 15, 2016}
\release{}
\author{CSinParallel Project}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


\textbf{Last Updated:} 2016-08-15

Welcome to the module for introducing students to MapReduce with Phoenix++!
The first section, \emph{What is MapReduce?} introduces students to the overall
paradigm of MapReduce, discusses the history of Phoenix++ MapReduce, and how it
differs from Hadoop and Google MapReduce. The next section, \emph{Counting Pease
with MapReduce} discusses how to use MapReduce to count words in a file, using
a famous poem from Mother Goose. The third section, entitled \emph{Getting Started
with Phoenix++}, explores the Phoenix++ code base, discusses files required for
custom implementations, and gives an overview of the word count example provided
by the framework.
Contents:


\chapter{What is MapReduce?}
\label{MRIntro/MRIntro:introducing-students-to-mapreduce-with-phoenix}\label{MRIntro/MRIntro:what-is-mapreduce}\label{MRIntro/MRIntro::doc}

\section{Motivation}
\label{MRIntro/MRIntro:motivation}
In today's world, multicore architectures are ubiquitous. But, the majority of
programs that people write are still serial. Why is that? While some people may
be unaware that they can leverage the multiple cores on their computers, the
truth is that parallel computing is very difficult. In many cases, the
programmer must consider many factors that have nothing to do with problem he
or she is trying to parallelize. For example, to implement a program in Pthreads,
a programmer must physically allocate, create and join any threads they want to
use. The programmer must also be aware of data races, and use synchronization
constructs as necessary.

This is not unique to Pthreads. In MPI for example, you have to explicitly
specify what messages you want to send to what node, and how to synchronize
messages. As you can imagine, this creates a lot of overhead for the
programmer. As those who have programmed previously in Pthreads, MPI, or OpenMP
can attest, debugging parallel programs can be very difficult! When things
execute in parallel, they execute \emph{non-deterministically}. This \href{https://en.wikipedia.org/wiki/Unbounded\_nondeterminism}{non-determinism}
can cause a lot of headaches.

As multicore and parallel systems became more prevalent, computer scientists
began to ask the question if parallel computing is harder that it needs to be.
Some libraries such as OpenMP ``hide'' some of the work required with threads
through the use of pragmas. Hiding implementation details is known as
abstraction. However, even with abstraction, the programming still has to worry
a lot about the ``management'' aspects of the program. Furthermore, similar
applications can be parallelized in the way. Researchers began exploring ways
to create an automated framework for parallel computing.


\section{Enter MapReduce}
\label{MRIntro/MRIntro:enter-mapreduce}
In 2004, Jeffrey Dean and Sanjay Ghemawhat of Google \href{http://static.usenix.org/publications/library/proceedings/osdi04/tech/full\_papers/dean/dean\_html/}{published a paper} on the
MapReduce paradigm. Google uses MapReduce as the backbone of its search engine,
and uses it for multiple operations. It is important to note that Google did
\emph{not} invent MapReduce; the paradigm has existed for decades in functional
languages. However, the paper's release was a watershed moment in parallel
computing, and spelled the beginning of an upsurge in interest in the paradigm
that has led to many innovations over the last decade.

Google's implementation of MapReduce is closed source and proprietary. In 2006,
work on the \href{http://hadoop.apache.org/}{Hadoop} project was started by Doug Cutting, an employee of Yahoo!.
Hadoop is named after a plush toy elephant belonging to Cutting's son, and the
eponymous elephant features prominently in the Hadoop logo. Over the last six
years, Hadoop has been widely adopted by many tech giants, including Amazon,
Facebook and Microsoft.

It is important to note that both Google's implementation of MapReduce and
Hadoop MapReduce were designed for very large datasets, on the order of
hundreds of gigabytes and petabytes. The goal is to efficiently streamline the
processing of these large numbers of documents by distributing them over
thousands of machines. Note that for smaller datasets, the system may have
limited benefit; the Hadoop Distributed File System (HDFS) can prove to be a
bottleneck. However, the concept of MapReduce is still very attractive to
programmers with smaller datasets or more limited computational resources, due
to its relative simplicity.

\begin{notice}{note}{Note:}
Want to play with a Hadoop system on the web? Check out \href{http://csinparallel.org/csinparallel/modules/IntroWMR.html}{WebMapReduce}!
Access the module at \href{http://csinparallel.org/csinparallel/modules/IntroWMR.html}{this link}.
\end{notice}


\section{Phoenix and Phoenix++}
\label{MRIntro/MRIntro:phoenix-and-phoenix}
In 2007, a team at Stanford University led by Christos Kozyrakis began
exploring how to implement the MapReduce paradigm on multi-core platform. Their
thread-based solution, \href{http://csl.stanford.edu/~christos/publications/2007.cmp\_mapreduce.hpca.pdf}{Phoenix},
won best paper at HPCA`07, and has been cited over 900 times. An update on Phoenix (\href{http://csl.stanford.edu/~christos/publications/2009.scalable\_phoenix.iiswc.pdf}{Phoenix 2})
was released in 2009. In 2011, \href{https://research.tableau.com/sites/default/files/mapreduce2011-talbot-phoenixplusplus.pdf}{Phoenix++} was released.
A complete re-write of the earlier Phoenix systems, Phoenix++ enables
development in C++, and significantly modularizes and improves the
performance of the original code base.

\begin{notice}{note}{Note:}
This entire module is based on Phoenix++ the latest release of
Phoenix. Please note that if you are interested in using the earlier
modules, these instructions may not directly apply.
\end{notice}


\chapter{Counting Pease With MapReduce}
\label{wordcount/wordcount:counting-pease-with-mapreduce}\label{wordcount/wordcount::doc}

\section{Word Frequency}
\label{wordcount/wordcount:word-frequency}
We will discuss a classic example called Word Frequency, or Word Count. In this
example, the goal is to identify the set of unique words in a text file and
compute their associated ``counts'' or frequencies. Consider the follow poem by
Mother Goose:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Pease}\PYG{o}{\PYGZhy{}}\PYG{n}{porridge} \PYG{n}{hot}
\PYG{n}{Pease}\PYG{o}{\PYGZhy{}}\PYG{n}{porridge} \PYG{n}{cold}
\PYG{n}{Pease}\PYG{o}{\PYGZhy{}}\PYG{n}{porridge} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{pot}
\PYG{n}{Nine} \PYG{n}{days} \PYG{n}{old}
\PYG{n}{Some} \PYG{n}{like} \PYG{n}{it} \PYG{n}{hot}
\PYG{n}{Some} \PYG{n}{like} \PYG{n}{it} \PYG{n}{cold}
\PYG{n}{Some} \PYG{n}{like} \PYG{n}{it} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{pot}
\PYG{n}{Nine} \PYG{n}{days} \PYG{n}{old}
\end{Verbatim}

If we were to count the word frequencies in this file, we may get output that
looks like the following:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cold} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{n}{days} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{n}{hot} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{o+ow}{in} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{n}{it} \PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{n}{like} \PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{n}{nine} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{n}{old} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{n}{pease}\PYG{o}{\PYGZhy{}}\PYG{n}{porridge} \PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{n}{pot} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{n}{some} \PYG{p}{:} \PYG{l+m+mi}{3}
\PYG{n}{the} \PYG{p}{:} \PYG{l+m+mi}{2}
\end{Verbatim}

Notice that each word is associated with the frequency of its occurrence in the
poem.


\section{Solving the Problem Using MapReduce}
\label{wordcount/wordcount:solving-the-problem-using-mapreduce}
In MapReduce, the programmer is responsible for mainly writing two serial
functions: \code{map()} and \code{reduce()}. The framework takes care of running
everything in parallel. The components of the system are as follows:
\begin{itemize}
\item {} 
The \code{map()} function takes a chunk of input, processes it, and outputs a
series of \emph{(key, value)} pairs. All instances of the \code{map()} function
(mappers) run independently and simultaneously. This is known as the Map
phase.

\item {} 
A Combiner function sorts all the \emph{(key,value)} pairs coming from the Map
phase. The combiner uses a hashing function to aggregate all the values
associated with a particular key. Thus, the ouput from the combiner is a
series of \emph{(key,list(value))} pairs.

\item {} 
The \code{reduce()} function takes \emph{(key, list(value))} pairs and performs a
\emph{reduction operation} on each. A reduction operation is any operation that
combines the values in some way. The output is a final \emph{(key, value)} pair,
where the value is the result of the reduction operation performed on the
list. Each instance of the reduce() function (reducer) run independently and in parallel.

\end{itemize}

So how do we calculate Word Frequency with MapReduce? In the following example,
we have three mappers and three reducers. For simplicity, we assume that the
file is split on new lines (\code{\textbackslash{}n}) although this need not always be the case. Each
mapper takes its assigned chunk of text and splits it into words, and
emits \emph{(key,value)} pairs where the key is an individual word, and the value is \code{1}.
If multiple instances of a word are assigned to the same mapper, the local
frequencies can be added and emitted instead.

Below, we have an illustration of the Map phase of the algorithm. Observe that
the first mapper is emitting a single \emph{(key,value)} pair of (\code{Pease-porridge,3}) instead
of three instances of the pair (\code{Pease-porridge, 1}). Notice that all mappers run
in parallell. This assumes that a local combination operation is occuring.
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{map}.png}
\caption{Figure 1: How the Map Phase of the algorithm works.}\label{wordcount/wordcount:id1}\end{figure}

The combiner acts as a synchronization point; all the mappers must finish prior
to the combiner finishing execution. The combiner constructs \emph{(key,list(value))} pairs from the output from the mappers. For example, mapper 2 produced
the \emph{(key,value)} pair (\code{it, 2}), while mapper 3 produced the \emph{(key,value)}
pair (\code{it, 1}). The combiner will aggregate these two pairs and output
(\code{it}, \code{{[}2,1{]}}).

After the combiner finishes executing, the \emph{(key,list(value))} pairs go to to
the reducers for processing. We refer to this as the Reduce phase. The figure
below illustrates the Reduce phase for this example. Each reducer gets assigned
a set of \emph{(key,list(value))} pairs. For each pair, it performs a reduction
operation. In this case, the reduction operation is addition; all the values
in the list are simply added together. For example, reducer 2 reduces the pair
(\code{Some, {[}2,1{]}}) to (\code{Some, 3}).
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{{reduce}.png}
\caption{Figure 2: How the Reduce Phase of the algorithm works.}\label{wordcount/wordcount:id2}\end{figure}

\begin{notice}{note}{Note:}
One thing we do not discuss here is \emph{fault tolerance}. Fault
tolerance is most important for large distributed systems. When you
have that many computers networked together, it’s likely that some
subset of them will fail. Fault tolerance allows us to recover from
failures on the fly. In the case of Google’s Mapreduce, fault
tolerance is maintained by constantly pinging nodes. If any node stays
silent for too long, the framework marks that node as being “dead”,
and redistributes its work to other worker nodes. Phoenix and
Phoenix++ both have fault tolerance protections. Phoenix++ has an
optional execution mode that enables a user to skip data records in
the case of segmentation faults and bus errors. This can be invoked
through the use of the signal handler.
\end{notice}


\chapter{Getting Started with Phoenix++}
\label{phoenix/phoenix:getting-started-with-phoenix}\label{phoenix/phoenix::doc}

\section{Introduction}
\label{phoenix/phoenix:introduction}
In this section, we will discuss the Phoenix++ wordcount example in detail. You
will need a basic knowledge of C/C++ to follow along with these concepts. You
can download a copy of the Phoenix++ word count example \href{http://d32ogoqmya1dw8.cloudfront.net/files/csinparallel/modules/code\_data\_phoenix\_module.gz}{here}. We will start by looking at the file
\code{word\_count.cpp}. At the top of the file, there are three structs we should
pay attention to:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// a passage from the text. The input data to the Map\PYGZhy{}Reduce}
\PYG{k}{struct} \PYG{n}{wc\PYGZus{}string} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{data}\PYG{p}{;}
    \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{len}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// a single null\PYGZhy{}terminated word}
\PYG{k}{struct} \PYG{n}{wc\PYGZus{}word} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{data}\PYG{p}{;}

    \PYG{c+c1}{// necessary functions to use this as a key}
    \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{\PYGZlt{}}\PYG{p}{(}\PYG{n}{wc\PYGZus{}word} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{other}\PYG{p}{.}\PYG{n}{data}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{bool} \PYG{k}{operator}\PYG{o}{=}\PYG{o}{=}\PYG{p}{(}\PYG{n}{wc\PYGZus{}word} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{other}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{other}\PYG{p}{.}\PYG{n}{data}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+c1}{// a hash for the word}
\PYG{k}{struct} \PYG{n}{wc\PYGZus{}word\PYGZus{}hash}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// FNV\PYGZhy{}1a hash for 64 bits}
    \PYG{k+kt}{size\PYGZus{}t} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{wc\PYGZus{}word} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{key}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{h} \PYG{o}{=} \PYG{n}{key}\PYG{p}{.}\PYG{n}{data}\PYG{p}{;}
        \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{v} \PYG{o}{=} \PYG{l+m+mi}{14695981039346656037ULL}\PYG{p}{;}
        \PYG{k}{while} \PYG{p}{(}\PYG{o}{*}\PYG{n}{h} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{n}{v} \PYG{o}{=} \PYG{p}{(}\PYG{n}{v} \PYG{o}{\PYGZca{}} \PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t}\PYG{p}{)}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{h}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{1099511628211ULL}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{v}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These three structs define the type of our input chunk (\code{wc\_string}), our keys
(\code{wc\_word}) and the hash function that we are going to use to aggregate
common keys (\code{wc\_word\_hash}). The \code{wc\_string} struct has a data pointer
field  (which points to to the start of the chunk), and a \code{len} field which
indicates the size of the chunk. The \code{wc\_word} struct contains only a
pointer to the start of a word, along with the defintions on how to compare
two ``words''. At this point, you may be asking yourself, \emph{but, how do you know
where a word ends?} Be patient; when we get to the main body of code, it will
all become clear. The last struct contains only an operator definition for \code{()},
which requires a key of type \code{wc\_count} as its single parameter. This is an
implementation of the
\href{https://en.wikipedia.org/wiki/Fowler-Noll-Vo\_hash\_function}{Fowler-Noll-Vo hash function}.

While other hash functions
can be used, it is best just to leave this code alone.


\section{WordsMR: The word count class}
\label{phoenix/phoenix:wordsmr-the-word-count-class}
For every application you write using Phoenix++, you will need to define a
class for it. Let's start by taking a look at the class header:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{WordsMR} \PYG{p}{:} \PYG{n}{public} \PYG{n}{MapReduceSort}\PYG{o}{\PYGZlt{}}\PYG{n}{WordsMR}\PYG{p}{,} \PYG{n}{wc\PYGZus{}string}\PYG{p}{,} \PYG{n}{wc\PYGZus{}word}\PYG{p}{,} \PYG{n}{uint64\PYGZus{}t}\PYG{p}{,}
                                     \PYG{n}{hash\PYGZus{}container}\PYG{o}{\PYGZlt{}}\PYG{n}{wc\PYGZus{}word}\PYG{p}{,} \PYG{n}{uint64\PYGZus{}t}\PYG{p}{,} \PYG{n}{sum\PYGZus{}combiner}\PYG{p}{,} \PYG{n}{wc\PYGZus{}word\PYGZus{}hash}\PYG{o}{\PYGZgt{}}
                                     \PYG{o}{\PYGZgt{}}
\end{Verbatim}

The first thing to note about this definition is that \code{WordsMR} is derived
from class \code{MapReduceSort}, which is defined in \code{mapreduce.h}. This is the
primary beauty of Phoenix++; to write your own MapReduce programs, you simply
overload the default function defined in the base class. We define the class
with the following parameters (in order):
\begin{itemize}
\item {} 
the implemented class type (\emph{Impl} = \code{WordsMR})

\item {} 
the input data type (\emph{D} = \code{wc\_string})

\item {} 
the key type (\emph{K} = \code{wc\_word})

\item {} 
the value type (\emph{V} = \code{uint\_64})

\item {} 
the definition of the hash container (\code{hash\_container\textless{}...\textgreater{}})

\end{itemize}

\code{hash\_container} defines the parameters for the hashtable used to aggregate
\emph{(key, value)} pairs. A full definition of the \code{hash\_container} class can be
found in \code{container.h}. It's input parameters are:
\begin{itemize}
\item {} 
the key type (\emph{K} = \code{wc\_word})

\item {} 
the value type (\emph{V} = \code{uint\_64})

\item {} 
the type of combiner function (\emph{Combiner} = \code{sum\_combiner})

\item {} 
The hash function to use (\emph{hash} = \code{wc\_word\_hash})

\end{itemize}

Note the use of the combiner \code{sum\_combiner}, an associative combiner
implemented in Phoenix++. This means, as collisions in our hash table occur,
the values are added together. This actually eliminates the need for a reduce
function in our application! The other type of combiner is known as the
\code{buffer\_combiner}, and reflects typical MapReduce behavior. This combiner
chains all the values together. The functions shown below are ones that are
commonly overloaded when creating a Phoenix++ MapReduce class:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Function Name
} & \textsf{\relax 
Description
}\\
\hline
\code{map()}
 & 
Defines the functionality for map tasks. The default
definition of the \code{map()} function is empty. This
function must be overloaded for every user-defined
MapReduce class.
\\
\hline
\code{reduce()}
 & 
Defines the functionality for the reduce tasks. By
default, the \code{reduce()} function generates a list
of \emph{(key,value)} pairs from a given key and
\emph{list(value)} input.
\\
\hline
\code{split()}
 & 
Defines how input data should be chunked. The
default \code{split()} function returns \code{0}. This
function must be overloaded for every user-defined
MapReduce class.
\\
\hline
\code{locate()}
 & 
Indicates where to access the input data from. By
default, the \code{locate()} function casts the input
data as a void pointer.
\\
\hline\end{tabulary}


For the word count application, the \code{map()}, \code{locate()} and \code{split()}
functions are overloaded as public methods.

The class declares a number of global variables, that will be initialized by
user input:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{char}\PYG{o}{*} \PYG{n}{data}\PYG{p}{;}
\PYG{n}{uint64\PYGZus{}t} \PYG{n}{data\PYGZus{}size}\PYG{p}{;}
\PYG{n}{uint64\PYGZus{}t} \PYG{n}{chunk\PYGZus{}size}\PYG{p}{;}
\PYG{n}{uint64\PYGZus{}t} \PYG{n}{splitter\PYGZus{}pos}\PYG{p}{;}
\end{Verbatim}

We can see these values getting initialized in the constructor below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{explicit} \PYG{n}{WordsMR}\PYG{p}{(}\PYG{n}{char}\PYG{o}{*} \PYG{n}{\PYGZus{}data}\PYG{p}{,} \PYG{n}{uint64\PYGZus{}t} \PYG{n}{length}\PYG{p}{,} \PYG{n}{uint64\PYGZus{}t} \PYG{n}{\PYGZus{}chunk\PYGZus{}size}\PYG{p}{)} \PYG{p}{:}
         \PYG{n}{data}\PYG{p}{(}\PYG{n}{\PYGZus{}data}\PYG{p}{)}\PYG{p}{,} \PYG{n}{data\PYGZus{}size}\PYG{p}{(}\PYG{n}{length}\PYG{p}{)}\PYG{p}{,} \PYG{n}{chunk\PYGZus{}size}\PYG{p}{(}\PYG{n}{\PYGZus{}chunk\PYGZus{}size}\PYG{p}{)}\PYG{p}{,}
         \PYG{n}{splitter\PYGZus{}pos}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\subsection{The locate() function}
\label{phoenix/phoenix:the-locate-function}
The first function declared in the public scope of the class is \code{locate()}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{void}\PYG{o}{*} \PYG{n+nf}{locate}\PYG{p}{(}\PYG{n}{data\PYGZus{}type}\PYG{o}{*} \PYG{n}{str}\PYG{p}{,} \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{len}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{str}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{data}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{Verbatim}

The \code{locate()} function takes two parameters: a pointer to the input data
type (\code{data\_type*}), and a length (\code{len}). It returns a pointer to the
start of readable data. In this case, it will be the data field of the
\code{wc\_string} struct, which is our input data type.


\subsection{The map() function}
\label{phoenix/phoenix:the-map-function}
The \code{map()} function is declared next. Its two parameters is the input data
type (passed by reference), and the ouput data container (\code{out}). Remember,
our input data type is \code{wc\_string}. Remember that \code{wc\_string} is a struct
with two fields: \code{data} and \code{len}. The input represents a ``chunk'' of data
which we want to parse words from and emit \emph{(key,value)} pairs associating each
word with the count of \code{1}:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{k+kt}{void} \PYG{n+nf}{map}\PYG{p}{(}\PYG{n}{data\PYGZus{}type} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{s}\PYG{p}{,} \PYG{n}{map\PYGZus{}container}\PYG{o}{\PYGZam{}} \PYG{n}{out}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{len}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{toupper}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{len}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}            
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{len} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}A\PYGZsq{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+s+sc}{\PYGZsq{}Z\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{start} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{len} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}A\PYGZsq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}Z\PYGZsq{}}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}\PYGZbs{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
                \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{n}{start}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
                \PYG{n}{wc\PYGZus{}word} \PYG{n}{word} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{s}\PYG{p}{.}\PYG{n}{data}\PYG{o}{+}\PYG{n}{start} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
                \PYG{n}{emit\PYGZus{}intermediate}\PYG{p}{(}\PYG{n}{out}\PYG{p}{,} \PYG{n}{word}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\end{Verbatim}

The first four lines of the function converts every character in the input
chunk to uppercase. The function \code{toupper} is declared in the standard header
file \code{cctype.h}. This is to ensure the word count application ignores case
as it counts words.

The while code block contains the majority of the work . It contains two inner
while loops and an if statement.
\begin{itemize}
\item {} 
The first inner while loop determines the starting point of the word. It
skips any characters that are outside the ASCII range of A to Z. As soon as
it exceeds the length of the string or hits an alphabetic character, it stops
incrementing \code{i}. This value of \code{i} is designated as the start of the
word (\code{start = i}).

\item {} 
The second inner while loop determines the end of a word. It keeps
incrementing \code{i}, so long as the current character is alphabetic, and the
value of \code{i} is less than the length of the input chunk. The variable \code{i}
stops incrementing once we hit a non-alphebetic character or the end of the
input chunk.

\end{itemize}

The next few line of code is crucial to understanding how the word count
applicaton works:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{s}\PYG{o}{.}\PYG{n}{data}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{wc\PYGZus{}word} \PYG{n}{word} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{s}\PYG{o}{.}\PYG{n}{data}\PYG{o}{+}\PYG{n}{start} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{emit\PYGZus{}intermediate}\PYG{p}{(}\PYG{n}{out}\PYG{p}{,} \PYG{n}{word}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Recall that \code{0} is the integer value of \code{\textbackslash{}0}, the null terminator, which
indicates where a string should be terminated. We define our key data
(\code{wc\_word word}) to be a pointer to our input chunk, at offset \code{start}.
Next, we emit the word key with the value \code{1}.

The above process repeats until all the valid words in the input chunk are
consumed.


\subsection{The split() function}
\label{phoenix/phoenix:the-split-function}
The \code{split()} function tokenizes the input prior to its going to the \code{map()}
function:

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cm}{/** wordcount split()}
\PYG{c+cm}{     *  Memory map the file and divide file on a word border i.e. a space.}
\PYG{c+cm}{     */}
    \PYG{k+kt}{int} \PYG{n+nf}{split}\PYG{p}{(}\PYG{n}{wc\PYGZus{}string}\PYG{o}{\PYGZam{}} \PYG{n}{out}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{c+cm}{/* End of data reached, return FALSE. */}
        \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{uint64\PYGZus{}t}\PYG{p}{)}\PYG{n}{splitter\PYGZus{}pos} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{data\PYGZus{}size}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+cm}{/* Determine the nominal end point. */}
        \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{end} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{min}\PYG{p}{(}\PYG{n}{splitter\PYGZus{}pos} \PYG{o}{+} \PYG{n}{chunk\PYGZus{}size}\PYG{p}{,} \PYG{n}{data\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+cm}{/* Move end point to next word break */}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{end} \PYG{o}{\PYGZlt{}} \PYG{n}{data\PYGZus{}size} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} 
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{} \PYGZsq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}\PYGZbs{}t\PYGZsq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
            \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}\PYGZbs{}r\PYGZsq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!}\PYG{o}{=} \PYG{l+s+sc}{\PYGZsq{}\PYGZbs{}n\PYGZsq{}}\PYG{p}{)}
            \PYG{n}{end}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

        \PYG{c+cm}{/* Set the start of the next data. */}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data} \PYG{o}{+} \PYG{n}{splitter\PYGZus{}pos}\PYG{p}{;}
        \PYG{n}{out}\PYG{p}{.}\PYG{n}{len} \PYG{o}{=} \PYG{n}{end} \PYG{o}{\PYGZhy{}} \PYG{n}{splitter\PYGZus{}pos}\PYG{p}{;}
        
        \PYG{n}{splitter\PYGZus{}pos} \PYG{o}{=} \PYG{n}{end}\PYG{p}{;}

        \PYG{c+cm}{/* Return true since the out data is valid. */}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{bool} \PYG{n+nf}{sort}\PYG{p}{(}\PYG{n}{keyval} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{a}\PYG{p}{,} \PYG{n}{keyval} \PYG{k}{const}\PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)} \PYG{k}{const}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{a}\PYG{p}{.}\PYG{n}{val} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{.}\PYG{n}{val} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{val} \PYG{o}{=}\PYG{o}{=} \PYG{n}{b}\PYG{p}{.}\PYG{n}{val} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{key}\PYG{p}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{b}\PYG{p}{.}\PYG{n}{key}\PYG{p}{.}\PYG{n}{data}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

Keep in mind while reading this code that the input file is in shared memory.
The function takes a single parameter, a reference to a \code{wc\_string} object,
which is our input data type. Recall that the variables \code{splitter\_pos} and
\code{data\_size} are global. The variable \code{splitter\_pos} tells us where we are
currently in the file. The variable \code{data\_size} represents the size of the
entire file. The variable \code{chunk\_size} represents the size of each chunk.

The first if statement simply ensures that our current position does not
exceed the bounds of the file. If so, we exit the function by returning 0
(indicating failure, and that there is nothing more to split).

We want each chunk to be approximately the same. We first determine a
``nominal'' end-point, or position to ``chunk'' the data:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{uint64\PYGZus{}t} \PYG{n}{end} \PYG{o}{=} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{splitter\PYGZus{}pos} \PYG{o}{+} \PYG{n}{chunk\PYGZus{}size}\PYG{p}{,} \PYG{n}{data\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Obviously, this end-point won't always work. What if we land in the middle of a
word? Therefore, we want to increment \code{end} until we hit a natural word
boundry. The \code{split()} function declares this boundry as being either a
space, tab, return carriage, or new line character. This is achieved by the
following code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{while}\PYG{p}{(}\PYG{n}{end} \PYG{o}{\PYGZlt{}} \PYG{n}{data\PYGZus{}size} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
          \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
          \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{data}\PYG{p}{[}\PYG{n}{end}\PYG{p}{]} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
          \PYG{n}{end}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\end{Verbatim}

Once we determine a valid end-point, we populate the inputted \code{wc\_string}
object:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{.}\PYG{n}{data} \PYG{o}{=} \PYG{n}{data} \PYG{o}{+} \PYG{n}{splitter\PYGZus{}pos}\PYG{p}{;}
\PYG{n}{out}\PYG{o}{.}\PYG{n}{len} \PYG{o}{=} \PYG{n}{end} \PYG{o}{\PYGZhy{}} \PYG{n}{splitter\PYGZus{}pos}\PYG{p}{;}
\end{Verbatim}

The starting point is set to data pointer plus the starting value of
\code{splitter\_pos}. The length is determined by subtracting \code{end} from
\code{splitter\_pos}.

Finally, we update \code{splitter\_pos} to be the end point (\code{end}), and return
\code{1} to indicate that we were able to successfully split the input.


\section{The main() function}
\label{phoenix/phoenix:the-main-function}
A simplified version of the \code{main()} function is shown below. This version
only shows the non memory mapped code. The memory mapped version of the code
can be viewed here. We also remove timing code for simplicity. The
\code{CHECK\_ERROR} function is defined in the file \code{stddefines.h} and is a
useful wrapper for error handling.

\begin{Verbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)} 
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{fd}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{fdata}\PYG{p}{;}
    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{disp\PYGZus{}num}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{stat} \PYG{n}{finfo}\PYG{p}{;}
    \PYG{k+kt}{char} \PYG{o}{*} \PYG{n}{fname}\PYG{p}{,} \PYG{o}{*} \PYG{n}{disp\PYGZus{}num\PYGZus{}str}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{timespec} \PYG{n}{begin}\PYG{p}{,} \PYG{n}{end}\PYG{p}{;}

    \PYG{n}{get\PYGZus{}time} \PYG{p}{(}\PYG{n}{begin}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Make sure a filename is specified}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{USAGE: \PYGZpc{}s \PYGZlt{}filename\PYGZgt{} [Top \PYGZsh{} of results to display]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{fname} \PYG{o}{=} \PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{disp\PYGZus{}num\PYGZus{}str} \PYG{o}{=} \PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Wordcount: Running...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Read in the file}
    \PYG{n}{CHECK\PYGZus{}ERROR}\PYG{p}{(}\PYG{p}{(}\PYG{n}{fd} \PYG{o}{=} \PYG{n}{open}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{n}{O\PYGZus{}RDONLY}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Get the file info (for file length)}
    \PYG{n}{CHECK\PYGZus{}ERROR}\PYG{p}{(}\PYG{n}{fstat}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{finfo}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{fdata} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{char} \PYG{o}{*}\PYG{p}{)}\PYG{n}{malloc} \PYG{p}{(}\PYG{n}{finfo}\PYG{p}{.}\PYG{n}{st\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CHECK\PYGZus{}ERROR} \PYG{p}{(}\PYG{n}{fdata} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{while}\PYG{p}{(}\PYG{n}{r} \PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k+kt}{uint64\PYGZus{}t}\PYG{p}{)}\PYG{n}{finfo}\PYG{p}{.}\PYG{n}{st\PYGZus{}size}\PYG{p}{)}
        \PYG{n}{r} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pread} \PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{fdata} \PYG{o}{+} \PYG{n}{r}\PYG{p}{,} \PYG{n}{finfo}\PYG{p}{.}\PYG{n}{st\PYGZus{}size}\PYG{p}{,} \PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CHECK\PYGZus{}ERROR} \PYG{p}{(}\PYG{n}{r} \PYG{o}{!}\PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{uint64\PYGZus{}t}\PYG{p}{)}\PYG{n}{finfo}\PYG{p}{.}\PYG{n}{st\PYGZus{}size}\PYG{p}{)}\PYG{p}{;}

    
    \PYG{c+c1}{// Get the number of results to display}
    \PYG{n}{CHECK\PYGZus{}ERROR}\PYG{p}{(}\PYG{p}{(}\PYG{n}{disp\PYGZus{}num} \PYG{o}{=} \PYG{p}{(}\PYG{n}{disp\PYGZus{}num\PYGZus{}str} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)} \PYG{o}{?} 
      \PYG{n+nl}{DEFAULT\PYGZus{}DISP\PYGZus{}NUM} \PYG{p}{:} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{disp\PYGZus{}num\PYGZus{}str}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{get\PYGZus{}time} \PYG{p}{(}\PYG{n}{end}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef TIMING}
    \PYG{n}{print\PYGZus{}time}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{initialize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{begin}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Wordcount: Calling MapReduce Scheduler Wordcount}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{get\PYGZus{}time} \PYG{p}{(}\PYG{n}{begin}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{WordsMR}\PYG{o}{:}\PYG{o}{:}\PYG{n}{keyval}\PYG{o}{\PYGZgt{}} \PYG{n}{result}\PYG{p}{;}    
    \PYG{n}{WordsMR} \PYG{n}{mapReduce}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{,} \PYG{n}{finfo}\PYG{p}{.}\PYG{n}{st\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{o}{*}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CHECK\PYGZus{}ERROR}\PYG{p}{(} \PYG{n}{mapReduce}\PYG{p}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{get\PYGZus{}time} \PYG{p}{(}\PYG{n}{end}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef TIMING}
    \PYG{n}{print\PYGZus{}time}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{library}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{begin}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Wordcount: MapReduce Completed}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{get\PYGZus{}time} \PYG{p}{(}\PYG{n}{begin}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{dn} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{min}\PYG{p}{(}\PYG{n}{disp\PYGZus{}num}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int}\PYG{p}{)}\PYG{n}{result}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{Wordcount: Results (TOP \PYGZpc{}d of \PYGZpc{}lu):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dn}\PYG{p}{,} \PYG{n}{result}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{uint64\PYGZus{}t} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{dn}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZpc{}15s \PYGZhy{} \PYGZpc{}lu}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{result}\PYG{p}{[}\PYG{n}{result}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{key}\PYG{p}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{result}\PYG{p}{[}\PYG{n}{result}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{val}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total: \PYGZpc{}lu}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{total}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{free} \PYG{p}{(}\PYG{n}{fdata}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{CHECK\PYGZus{}ERROR}\PYG{p}{(}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{get\PYGZus{}time} \PYG{p}{(}\PYG{n}{end}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef TIMING}
    \PYG{n}{print\PYGZus{}time}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{finalize}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{begin}\PYG{p}{,} \PYG{n}{end}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

We analyze this code in parts:

In the first part, we are simply setting up variables. Users running the
program are required to input a file, and may choose to specify the top number
of results to display. Variables are declared to facillitate file reading and
command line parsing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{int} \PYG{n}{fd}\PYG{p}{;}
\PYG{n}{char} \PYG{o}{*} \PYG{n}{fdata}\PYG{p}{;}
\PYG{n}{unsigned} \PYG{n+nb}{int} \PYG{n}{disp\PYGZus{}num}\PYG{p}{;}
\PYG{n}{struct} \PYG{n}{stat} \PYG{n}{finfo}\PYG{p}{;}
\PYG{n}{char} \PYG{o}{*} \PYG{n}{fname}\PYG{p}{,} \PYG{o}{*} \PYG{n}{disp\PYGZus{}num\PYGZus{}str}\PYG{p}{;}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Make} \PYG{n}{sure} \PYG{n}{a} \PYG{n}{filename} \PYG{o+ow}{is} \PYG{n}{specified}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{==} \PYG{n}{NULL}\PYG{p}{)}
 \PYG{p}{\PYGZob{}}
       \PYG{n}{printf}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{USAGE: }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{  [Top \PYGZsh{} of results to display]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\PYG{n}{fname} \PYG{o}{=} \PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{disp\PYGZus{}num\PYGZus{}str} \PYG{o}{=} \PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\end{Verbatim}

We next open the file for reading, and get its size using the \code{fstat} function.
We \code{malloc()} a block of memory, and have the descriptor \code{fdata} point to
it. Next, we read the file into memory using the \code{pread()} system call. We
also check to see if the user inputted the optional parameter that sets the
maximum number of entries to display. If so, we update the variable
\code{DEFAULT\_DISP\_NUM} to reflect this amount:

\begin{Verbatim}[commandchars=\\\{\}]
uint64\PYGZus{}t r = 0;
fdata = (char *)malloc (finfo.st\PYGZus{}size);
CHECK\PYGZus{}ERROR (fdata == NULL);
while(r \PYGZlt{} (uint64\PYGZus{}t)finfo.st\PYGZus{}size)
       r += pread (fd, fdata + r, finfo.st\PYGZus{}size, r);
CHECK\PYGZus{}ERROR (r != (uint64\PYGZus{}t)finfo.st\PYGZus{}size);
// Get the number of results to display
CHECK\PYGZus{}ERROR((disp\PYGZus{}num = (disp\PYGZus{}num\PYGZus{}str == NULL) ?
             DEFAULT\PYGZus{}DISP\PYGZus{}NUM : atoi(disp\PYGZus{}num\PYGZus{}str)) \PYGZlt{}= 0);
\end{Verbatim}

Now the magic happens: we run our MapReduce job. This is easily accomplished
in three lines. We first instantiate a \code{result} vector. We instantiate a
mapreduce job with the line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{WordsMR} \PYG{n}{mapReduce}\PYG{p}{(}\PYG{n}{fdata}\PYG{p}{,} \PYG{n}{finfo}\PYG{o}{.}\PYG{n}{st\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{o}{*}\PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Here, \code{fdata} will bind to the data pointer in \code{WordsMR}, \code{finfo.st\_size}
will bind to \code{data\_size} and \code{chunk\_size} wil be set to the quantity
\code{1024*1024}. The following line just ensure the result array is non empty:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CHECK\PYGZus{}ERROR}\PYG{p}{(} \PYG{n}{mapReduce}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

The final part of the code prints out the top \code{DEFAULT\_DISP\_NUM} entries,
sorted in order of greatest to least count. Since the output of the MapReduce
task is in sorted descending order, it suffices just to print the first
\code{DEFAULT\_DISP\_NUM} values. A second loop counts the total number of words
found:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{unsigned} \PYG{n+nb}{int} \PYG{n}{dn} \PYG{o}{=} \PYG{n}{std}\PYG{p}{:}\PYG{p}{:}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{disp\PYGZus{}num}\PYG{p}{,} \PYG{p}{(}\PYG{n}{unsigned} \PYG{n+nb}{int}\PYG{p}{)}\PYG{n}{result}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Wordcount: Results (TOP }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{ of }\PYG{l+s+si}{\PYGZpc{}lu}\PYG{l+s+s2}{):}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dn}\PYG{p}{,} \PYG{n}{result}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{uint64\PYGZus{}t} \PYG{n}{total} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{dn}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
     \PYG{n}{printf}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}15s}\PYG{l+s+s2}{ \PYGZhy{} }\PYG{l+s+si}{\PYGZpc{}lu}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{result}\PYG{p}{[}\PYG{n}{result}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{key}\PYG{o}{.}\PYG{n}{data}\PYG{p}{,} \PYG{n}{result}\PYG{p}{[}\PYG{n}{result}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{size\PYGZus{}t} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{result}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{n}{total} \PYG{o}{+}\PYG{o}{=} \PYG{n}{result}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{val}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{printf}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total: }\PYG{l+s+si}{\PYGZpc{}lu}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{total}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Finally, the \code{fdata} pointer is freed and we end the program:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{free} \PYG{p}{(}\PYG{n}{fdata}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{CHECK\PYGZus{}ERROR}\PYG{p}{(}\PYG{n}{close}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{Verbatim}


\section{Running the Code}
\label{phoenix/phoenix:running-the-code}
We prepared a simplified version of the word count program, in this archive called phoenix++-wc.tar.gz, which shows what a standalone Phoenix++ application looks like. Alternatively, you can access the official Phoenix++
release at this link. The following instructions assume that you downloaded the
phoenix++-wc.tar.gz file.

After downloading the file, untar it with the following command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tar} \PYG{o}{\PYGZhy{}}\PYG{n}{xzvf} \PYG{n}{phoenix}\PYG{o}{+}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{n}{wc}\PYG{o}{.}\PYG{n}{tar}\PYG{o}{.}\PYG{n}{gz}
\end{Verbatim}

Let's look at this folder's directory structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{data}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{dickens}\PYG{o}{.}\PYG{n}{txt}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{sherlock}\PYG{o}{.}\PYG{n}{txt}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Defines}\PYG{o}{.}\PYG{n}{mk}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{docs}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{2011.}\PYG{n}{phoenixplus}\PYG{o}{.}\PYG{n}{mapreduce}\PYG{o}{.}\PYG{n}{pdf}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{include}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{atomic}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{combiner}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{container}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{locality}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{map\PYGZus{}reduce}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{processor}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{scheduler}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{stddefines}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{synch}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{task\PYGZus{}queue}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{thread\PYGZus{}pool}\PYG{o}{.}\PYG{n}{h}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{lib}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Makefile}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{README}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{src}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Makefile}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{task\PYGZus{}queue}\PYG{o}{.}\PYG{n}{cpp}
\PYG{o}{\textbar{}}   \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{thread\PYGZus{}pool}\PYG{o}{.}\PYG{n}{cpp}
\PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{word\PYGZus{}count}
    \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Makefile}
    \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{README}
    \PYG{o}{\textbar{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{word\PYGZus{}count}\PYG{o}{.}\PYG{n}{cpp}
\end{Verbatim}

The folder \code{data} contains some sample data files for you to play with. The
file \code{Defines.mk} contains many of the compiler flags and other directives
needed to compile our code. The \code{docs} folder contains the Phoenix++ paper
that you can read. The \code{include} folder contains all the header files we need
for our Phoenix++ application. The \code{lib} directory is currently empty; once
we compile our code, it will contain the phoenix++ library file,
\code{libphoenix.a}. The \code{src} folder contains the code needed to make the
Phoenix++ library file. Lastly, our word count application is located in the
directory \code{word\_count}.
\begin{description}
\item[{To compile the application, run the \code{make} command in the main Phoenix++-wc}] \leavevmode
directory:

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{make}
\end{Verbatim}

Let's run the application on the file \code{dickens.txt}. This file is 21MB, and
contains the collective works of Charles Dickens. Run the application with the
following command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{time} \PYG{o}{\PYGZhy{}}\PYG{n}{p} \PYG{o}{.}\PYG{o}{/}\PYG{n}{word\PYGZus{}count}\PYG{o}{/}\PYG{n}{word\PYGZus{}count} \PYG{n}{data}\PYG{o}{/}\PYG{n}{dickens}\PYG{o}{.}\PYG{n}{txt}
\end{Verbatim}

This will show you the top 10 most frequent words detected in \code{dickens.txt}.
To see detailed timing information, uncomment the line \code{\#define TIMING} in
\code{include/stddefines.h}.

Below you will find a series of exercises to explore the example further.
Happy analyzing!


\section{Exercises}
\label{phoenix/phoenix:exercises}
Let's explore the \code{word\_count.cpp} file a bit futher by modifying it slightly.
Remember, every time you change this file, you must recompile your code using
the \code{make} command!
\begin{itemize}
\item {} 
Run the word count program to print the top 20 words, the top 50 words, and
the top 100 words. How does the run-time change?

\item {} 
Most of the words that have been showing up are common short words, such as
``and'', ``the'', ``of'', ``in'', and ``a''. Modify the \code{map()} function to only
print out words that are five characters or longer. What are the top ten
words now? How does Charles Dickens' top 10 words differ from Arthur Conan
Doyle's?

\item {} 
Use the setenv command to set the \code{MR\_NUMTHREADS} environmental variable to
a user inutted number of threads in \code{main.cpp}. Check the setenv
documentation for more details.

\item {} 
Check the number of CPU cores on your machine by checking \code{/proc/cpuinfo}.
Vary the number of threads from \emph{1...c} where \emph{c} is the number of CPU cores.
Plot your timing results using Matplotlib.

\item {} 
\emph{Challenge}: The words that are showing up are still those that largely
reflect the grammar of an author's writing. These are known as function words.
Modify the \code{map()} function to \emph{exclude} any words that are function words.
A list of 321 common function words can be found at this link.

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
