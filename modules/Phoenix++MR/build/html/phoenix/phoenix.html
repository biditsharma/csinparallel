<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting Started with Phoenix++ &mdash; Introducion to MapReduce with Phoenix++</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="Introducion to MapReduce with Phoenix++" href="../index.html" />
    <link rel="prev" title="Counting Pease With MapReduce" href="../wordcount/wordcount.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../wordcount/wordcount.html" title="Counting Pease With MapReduce"
             accesskey="P">previous</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">MapReduce with Pheonix++</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="getting-started-with-phoenix">
<h1>Getting Started with Phoenix++<a class="headerlink" href="#getting-started-with-phoenix" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will discuss the Phoenix++ wordcount example in detail. You
will need a basic knowledge of C/C++ to follow along with these concepts. You
can download a copy of the Phoenix++ word count example <a class="reference external" href="http://d32ogoqmya1dw8.cloudfront.net/files/csinparallel/modules/code_data_phoenix_module.gz">here</a>. We will start by looking at the file
<code class="docutils literal"><span class="pre">word_count.cpp</span></code>. At the top of the file, there are three structs we should
pay attention to:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// a passage from the text. The input data to the Map-Reduce</span>
<span class="k">struct</span> <span class="n">wc_string</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// a single null-terminated word</span>
<span class="k">struct</span> <span class="n">wc_word</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

    <span class="c1">// necessary functions to use this as a key</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">wc_word</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">wc_word</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// a hash for the word</span>
<span class="k">struct</span> <span class="n">wc_word_hash</span>
<span class="p">{</span>
    <span class="c1">// FNV-1a hash for 64 bits</span>
    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">wc_word</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">14695981039346656037ULL</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">^</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">++</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">1099511628211ULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>These three structs define the type of our input chunk (<code class="docutils literal"><span class="pre">wc_string</span></code>), our keys
(<code class="docutils literal"><span class="pre">wc_word</span></code>) and the hash function that we are going to use to aggregate
common keys (<code class="docutils literal"><span class="pre">wc_word_hash</span></code>). The <code class="docutils literal"><span class="pre">wc_string</span></code> struct has a data pointer
field  (which points to to the start of the chunk), and a <code class="docutils literal"><span class="pre">len</span></code> field which
indicates the size of the chunk. The <code class="docutils literal"><span class="pre">wc_word</span></code> struct contains only a
pointer to the start of a word, along with the defintions on how to compare
two &#8220;words&#8221;. At this point, you may be asking yourself, <em>but, how do you know
where a word ends?</em> Be patient; when we get to the main body of code, it will
all become clear. The last struct contains only an operator definition for <code class="docutils literal"><span class="pre">()</span></code>,
which requires a key of type <code class="docutils literal"><span class="pre">wc_count</span></code> as its single parameter. This is an
implementation of the
<a class="reference external" href="https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function">Fowler-Noll-Vo hash function</a>.</p>
<p>While other hash functions
can be used, it is best just to leave this code alone.</p>
</div>
<div class="section" id="wordsmr-the-word-count-class">
<h2>WordsMR: The word count class<a class="headerlink" href="#wordsmr-the-word-count-class" title="Permalink to this headline">¶</a></h2>
<p>For every application you write using Phoenix++, you will need to define a
class for it. Let&#8217;s start by taking a look at the class header:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WordsMR</span> <span class="p">:</span> <span class="n">public</span> <span class="n">MapReduceSort</span><span class="o">&lt;</span><span class="n">WordsMR</span><span class="p">,</span> <span class="n">wc_string</span><span class="p">,</span> <span class="n">wc_word</span><span class="p">,</span> <span class="n">uint64_t</span><span class="p">,</span>
                                     <span class="n">hash_container</span><span class="o">&lt;</span><span class="n">wc_word</span><span class="p">,</span> <span class="n">uint64_t</span><span class="p">,</span> <span class="n">sum_combiner</span><span class="p">,</span> <span class="n">wc_word_hash</span><span class="o">&gt;</span>
                                     <span class="o">&gt;</span>
</pre></div>
</div>
<p>The first thing to note about this definition is that <code class="docutils literal"><span class="pre">WordsMR</span></code> is derived
from class <code class="docutils literal"><span class="pre">MapReduceSort</span></code>, which is defined in <code class="docutils literal"><span class="pre">mapreduce.h</span></code>. This is the
primary beauty of Phoenix++; to write your own MapReduce programs, you simply
overload the default function defined in the base class. We define the class
with the following parameters (in order):</p>
<ul class="simple">
<li>the implemented class type (<em>Impl</em> = <code class="docutils literal"><span class="pre">WordsMR</span></code>)</li>
<li>the input data type (<em>D</em> = <code class="docutils literal"><span class="pre">wc_string</span></code>)</li>
<li>the key type (<em>K</em> = <code class="docutils literal"><span class="pre">wc_word</span></code>)</li>
<li>the value type (<em>V</em> = <code class="docutils literal"><span class="pre">uint_64</span></code>)</li>
<li>the definition of the hash container (<code class="docutils literal"><span class="pre">hash_container&lt;...&gt;</span></code>)</li>
</ul>
<p><code class="docutils literal"><span class="pre">hash_container</span></code> defines the parameters for the hashtable used to aggregate
<em>(key, value)</em> pairs. A full definition of the <code class="docutils literal"><span class="pre">hash_container</span></code> class can be
found in <code class="docutils literal"><span class="pre">container.h</span></code>. It&#8217;s input parameters are:</p>
<ul class="simple">
<li>the key type (<em>K</em> = <code class="docutils literal"><span class="pre">wc_word</span></code>)</li>
<li>the value type (<em>V</em> = <code class="docutils literal"><span class="pre">uint_64</span></code>)</li>
<li>the type of combiner function (<em>Combiner</em> = <code class="docutils literal"><span class="pre">sum_combiner</span></code>)</li>
<li>The hash function to use (<em>hash</em> = <code class="docutils literal"><span class="pre">wc_word_hash</span></code>)</li>
</ul>
<p>Note the use of the combiner <code class="docutils literal"><span class="pre">sum_combiner</span></code>, an associative combiner
implemented in Phoenix++. This means, as collisions in our hash table occur,
the values are added together. This actually eliminates the need for a reduce
function in our application! The other type of combiner is known as the
<code class="docutils literal"><span class="pre">buffer_combiner</span></code>, and reflects typical MapReduce behavior. This combiner
chains all the values together. The functions shown below are ones that are
commonly overloaded when creating a Phoenix++ MapReduce class:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Function Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">map()</span></code></td>
<td>Defines the functionality for map tasks. The default
definition of the <code class="docutils literal"><span class="pre">map()</span></code> function is empty. This
function must be overloaded for every user-defined
MapReduce class.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">reduce()</span></code></td>
<td>Defines the functionality for the reduce tasks. By
default, the <code class="docutils literal"><span class="pre">reduce()</span></code> function generates a list
of <em>(key,value)</em> pairs from a given key and
<em>list(value)</em> input.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">split()</span></code></td>
<td>Defines how input data should be chunked. The
default <code class="docutils literal"><span class="pre">split()</span></code> function returns <code class="docutils literal"><span class="pre">0</span></code>. This
function must be overloaded for every user-defined
MapReduce class.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">locate()</span></code></td>
<td>Indicates where to access the input data from. By
default, the <code class="docutils literal"><span class="pre">locate()</span></code> function casts the input
data as a void pointer.</td>
</tr>
</tbody>
</table>
<p>For the word count application, the <code class="docutils literal"><span class="pre">map()</span></code>, <code class="docutils literal"><span class="pre">locate()</span></code> and <code class="docutils literal"><span class="pre">split()</span></code>
functions are overloaded as public methods.</p>
<p>The class declares a number of global variables, that will be initialized by
user input:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="n">uint64_t</span> <span class="n">data_size</span><span class="p">;</span>
<span class="n">uint64_t</span> <span class="n">chunk_size</span><span class="p">;</span>
<span class="n">uint64_t</span> <span class="n">splitter_pos</span><span class="p">;</span>
</pre></div>
</div>
<p>We can see these values getting initialized in the constructor below.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">explicit</span> <span class="n">WordsMR</span><span class="p">(</span><span class="n">char</span><span class="o">*</span> <span class="n">_data</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">_chunk_size</span><span class="p">)</span> <span class="p">:</span>
         <span class="n">data</span><span class="p">(</span><span class="n">_data</span><span class="p">),</span> <span class="n">data_size</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">chunk_size</span><span class="p">(</span><span class="n">_chunk_size</span><span class="p">),</span>
         <span class="n">splitter_pos</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<div class="section" id="the-locate-function">
<h3>The locate() function<a class="headerlink" href="#the-locate-function" title="Permalink to this headline">¶</a></h3>
<p>The first function declared in the public scope of the class is <code class="docutils literal"><span class="pre">locate()</span></code>:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="kt">void</span><span class="o">*</span> <span class="nf">locate</span><span class="p">(</span><span class="n">data_type</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The <code class="docutils literal"><span class="pre">locate()</span></code> function takes two parameters: a pointer to the input data
type (<code class="docutils literal"><span class="pre">data_type*</span></code>), and a length (<code class="docutils literal"><span class="pre">len</span></code>). It returns a pointer to the
start of readable data. In this case, it will be the data field of the
<code class="docutils literal"><span class="pre">wc_string</span></code> struct, which is our input data type.</p>
</div>
<div class="section" id="the-map-function">
<h3>The map() function<a class="headerlink" href="#the-map-function" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">map()</span></code> function is declared next. Its two parameters is the input data
type (passed by reference), and the ouput data container (<code class="docutils literal"><span class="pre">out</span></code>). Remember,
our input data type is <code class="docutils literal"><span class="pre">wc_string</span></code>. Remember that <code class="docutils literal"><span class="pre">wc_string</span></code> is a struct
with two fields: <code class="docutils literal"><span class="pre">data</span></code> and <code class="docutils literal"><span class="pre">len</span></code>. The input represents a &#8220;chunk&#8221; of data
which we want to parse words from and emit <em>(key,value)</em> pairs associating each
word with the count of <code class="docutils literal"><span class="pre">1</span></code>:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="kt">void</span> <span class="nf">map</span><span class="p">(</span><span class="n">data_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">map_container</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
        <span class="p">{</span>            
            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;A&#39;</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;Z&#39;</span><span class="p">))</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="kt">uint64_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\&#39;&#39;</span><span class="p">))</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">wc_word</span> <span class="n">word</span> <span class="o">=</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="o">+</span><span class="n">start</span> <span class="p">};</span>
                <span class="n">emit_intermediate</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The first four lines of the function converts every character in the input
chunk to uppercase. The function <code class="docutils literal"><span class="pre">toupper</span></code> is declared in the standard header
file <code class="docutils literal"><span class="pre">cctype.h</span></code>. This is to ensure the word count application ignores case
as it counts words.</p>
<p>The while code block contains the majority of the work . It contains two inner
while loops and an if statement.</p>
<ul class="simple">
<li>The first inner while loop determines the starting point of the word. It
skips any characters that are outside the ASCII range of A to Z. As soon as
it exceeds the length of the string or hits an alphabetic character, it stops
incrementing <code class="docutils literal"><span class="pre">i</span></code>. This value of <code class="docutils literal"><span class="pre">i</span></code> is designated as the start of the
word (<code class="docutils literal"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">i</span></code>).</li>
<li>The second inner while loop determines the end of a word. It keeps
incrementing <code class="docutils literal"><span class="pre">i</span></code>, so long as the current character is alphabetic, and the
value of <code class="docutils literal"><span class="pre">i</span></code> is less than the length of the input chunk. The variable <code class="docutils literal"><span class="pre">i</span></code>
stops incrementing once we hit a non-alphebetic character or the end of the
input chunk.</li>
</ul>
<p>The next few line of code is crucial to understanding how the word count
applicaton works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">wc_word</span> <span class="n">word</span> <span class="o">=</span> <span class="p">{</span> <span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="o">+</span><span class="n">start</span> <span class="p">};</span>
<span class="n">emit_intermediate</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Recall that <code class="docutils literal"><span class="pre">0</span></code> is the integer value of <code class="docutils literal"><span class="pre">\0</span></code>, the null terminator, which
indicates where a string should be terminated. We define our key data
(<code class="docutils literal"><span class="pre">wc_word</span> <span class="pre">word</span></code>) to be a pointer to our input chunk, at offset <code class="docutils literal"><span class="pre">start</span></code>.
Next, we emit the word key with the value <code class="docutils literal"><span class="pre">1</span></code>.</p>
<p>The above process repeats until all the valid words in the input chunk are
consumed.</p>
</div>
<div class="section" id="the-split-function">
<h3>The split() function<a class="headerlink" href="#the-split-function" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">split()</span></code> function tokenizes the input prior to its going to the <code class="docutils literal"><span class="pre">map()</span></code>
function:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre><span></span>    <span class="cm">/** wordcount split()</span>
<span class="cm">     *  Memory map the file and divide file on a word border i.e. a space.</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="nf">split</span><span class="p">(</span><span class="n">wc_string</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* End of data reached, return FALSE. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">splitter_pos</span> <span class="o">&gt;=</span> <span class="n">data_size</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Determine the nominal end point. */</span>
        <span class="kt">uint64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">splitter_pos</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>

        <span class="cm">/* Move end point to next word break */</span>
        <span class="k">while</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">data_size</span> <span class="o">&amp;&amp;</span> 
            <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\t&#39;</span> <span class="o">&amp;&amp;</span>
            <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="n">end</span><span class="o">++</span><span class="p">;</span>

        <span class="cm">/* Set the start of the next data. */</span>
        <span class="n">out</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="n">splitter_pos</span><span class="p">;</span>
        <span class="n">out</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">splitter_pos</span><span class="p">;</span>
        
        <span class="n">splitter_pos</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

        <span class="cm">/* Return true since the out data is valid. */</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">sort</span><span class="p">(</span><span class="n">keyval</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">keyval</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span> <span class="o">||</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Keep in mind while reading this code that the input file is in shared memory.
The function takes a single parameter, a reference to a <code class="docutils literal"><span class="pre">wc_string</span></code> object,
which is our input data type. Recall that the variables <code class="docutils literal"><span class="pre">splitter_pos</span></code> and
<code class="docutils literal"><span class="pre">data_size</span></code> are global. The variable <code class="docutils literal"><span class="pre">splitter_pos</span></code> tells us where we are
currently in the file. The variable <code class="docutils literal"><span class="pre">data_size</span></code> represents the size of the
entire file. The variable <code class="docutils literal"><span class="pre">chunk_size</span></code> represents the size of each chunk.</p>
<p>The first if statement simply ensures that our current position does not
exceed the bounds of the file. If so, we exit the function by returning 0
(indicating failure, and that there is nothing more to split).</p>
<p>We want each chunk to be approximately the same. We first determine a
&#8220;nominal&#8221; end-point, or position to &#8220;chunk&#8221; the data:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">uint64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">splitter_pos</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
</pre></div>
</div>
<p>Obviously, this end-point won&#8217;t always work. What if we land in the middle of a
word? Therefore, we want to increment <code class="docutils literal"><span class="pre">end</span></code> until we hit a natural word
boundry. The <code class="docutils literal"><span class="pre">split()</span></code> function declares this boundry as being either a
space, tab, return carriage, or new line character. This is achieved by the
following code:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">data_size</span> <span class="o">&amp;&amp;</span>
          <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">&amp;&amp;</span>
          <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
          <span class="n">end</span><span class="o">++</span><span class="p">;</span>
</pre></div>
</div>
<p>Once we determine a valid end-point, we populate the inputted <code class="docutils literal"><span class="pre">wc_string</span></code>
object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="n">splitter_pos</span><span class="p">;</span>
<span class="n">out</span><span class="o">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">splitter_pos</span><span class="p">;</span>
</pre></div>
</div>
<p>The starting point is set to data pointer plus the starting value of
<code class="docutils literal"><span class="pre">splitter_pos</span></code>. The length is determined by subtracting <code class="docutils literal"><span class="pre">end</span></code> from
<code class="docutils literal"><span class="pre">splitter_pos</span></code>.</p>
<p>Finally, we update <code class="docutils literal"><span class="pre">splitter_pos</span></code> to be the end point (<code class="docutils literal"><span class="pre">end</span></code>), and return
<code class="docutils literal"><span class="pre">1</span></code> to indicate that we were able to successfully split the input.</p>
</div>
</div>
<div class="section" id="the-main-function">
<h2>The main() function<a class="headerlink" href="#the-main-function" title="Permalink to this headline">¶</a></h2>
<p>A simplified version of the <code class="docutils literal"><span class="pre">main()</span></code> function is shown below. This version
only shows the non memory mapped code. The memory mapped version of the code
can be viewed here. We also remove timing code for simplicity. The
<code class="docutils literal"><span class="pre">CHECK_ERROR</span></code> function is defined in the file <code class="docutils literal"><span class="pre">stddefines.h</span></code> and is a
useful wrapper for error handling.</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">fdata</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">disp_num</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">stat</span> <span class="n">finfo</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">fname</span><span class="p">,</span> <span class="o">*</span> <span class="n">disp_num_str</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

    <span class="n">get_time</span> <span class="p">(</span><span class="n">begin</span><span class="p">);</span>

    <span class="c1">// Make sure a filename is specified</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;USAGE: %s &lt;filename&gt; [Top # of results to display]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fname</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">disp_num_str</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Wordcount: Running...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="c1">// Read in the file</span>
    <span class="n">CHECK_ERROR</span><span class="p">((</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Get the file info (for file length)</span>
    <span class="n">CHECK_ERROR</span><span class="p">(</span><span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">finfo</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">fdata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span> <span class="p">(</span><span class="n">finfo</span><span class="p">.</span><span class="n">st_size</span><span class="p">);</span>
    <span class="n">CHECK_ERROR</span> <span class="p">(</span><span class="n">fdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">finfo</span><span class="p">.</span><span class="n">st_size</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="n">pread</span> <span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">fdata</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">finfo</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">CHECK_ERROR</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">finfo</span><span class="p">.</span><span class="n">st_size</span><span class="p">);</span>

    
    <span class="c1">// Get the number of results to display</span>
    <span class="n">CHECK_ERROR</span><span class="p">((</span><span class="n">disp_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">disp_num_str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> 
      <span class="nl">DEFAULT_DISP_NUM</span> <span class="p">:</span> <span class="n">atoi</span><span class="p">(</span><span class="n">disp_num_str</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">get_time</span> <span class="p">(</span><span class="n">end</span><span class="p">);</span>

    <span class="cp">#ifdef TIMING</span>
    <span class="n">print_time</span><span class="p">(</span><span class="s">&quot;initialize&quot;</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="cp">#endif</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Wordcount: Calling MapReduce Scheduler Wordcount</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">get_time</span> <span class="p">(</span><span class="n">begin</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">WordsMR</span><span class="o">::</span><span class="n">keyval</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>    
    <span class="n">WordsMR</span> <span class="n">mapReduce</span><span class="p">(</span><span class="n">fdata</span><span class="p">,</span> <span class="n">finfo</span><span class="p">.</span><span class="n">st_size</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
    <span class="n">CHECK_ERROR</span><span class="p">(</span> <span class="n">mapReduce</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">get_time</span> <span class="p">(</span><span class="n">end</span><span class="p">);</span>

    <span class="cp">#ifdef TIMING</span>
    <span class="n">print_time</span><span class="p">(</span><span class="s">&quot;library&quot;</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="cp">#endif</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Wordcount: MapReduce Completed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">get_time</span> <span class="p">(</span><span class="n">begin</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">disp_num</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Wordcount: Results (TOP %d of %lu):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="kt">uint64_t</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%15s - %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Total: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>

    <span class="n">free</span> <span class="p">(</span><span class="n">fdata</span><span class="p">);</span>

    <span class="n">CHECK_ERROR</span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">get_time</span> <span class="p">(</span><span class="n">end</span><span class="p">);</span>

    <span class="cp">#ifdef TIMING</span>
    <span class="n">print_time</span><span class="p">(</span><span class="s">&quot;finalize&quot;</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="cp">#endif</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>We analyze this code in parts:</p>
<p>In the first part, we are simply setting up variables. Users running the
program are required to input a file, and may choose to specify the top number
of results to display. Variables are declared to facillitate file reading and
command line parsing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">fd</span><span class="p">;</span>
<span class="n">char</span> <span class="o">*</span> <span class="n">fdata</span><span class="p">;</span>
<span class="n">unsigned</span> <span class="nb">int</span> <span class="n">disp_num</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">stat</span> <span class="n">finfo</span><span class="p">;</span>
<span class="n">char</span> <span class="o">*</span> <span class="n">fname</span><span class="p">,</span> <span class="o">*</span> <span class="n">disp_num_str</span><span class="p">;</span>
<span class="o">//</span> <span class="n">Make</span> <span class="n">sure</span> <span class="n">a</span> <span class="n">filename</span> <span class="ow">is</span> <span class="n">specified</span>
<span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">)</span>
 <span class="p">{</span>
       <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;USAGE: </span><span class="si">%s</span><span class="s2">  [Top # of results to display]</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
 <span class="p">}</span>
<span class="n">fname</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">disp_num_str</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>We next open the file for reading, and get its size using the <code class="docutils literal"><span class="pre">fstat</span></code> function.
We <code class="docutils literal"><span class="pre">malloc()</span></code> a block of memory, and have the descriptor <code class="docutils literal"><span class="pre">fdata</span></code> point to
it. Next, we read the file into memory using the <code class="docutils literal"><span class="pre">pread()</span></code> system call. We
also check to see if the user inputted the optional parameter that sets the
maximum number of entries to display. If so, we update the variable
<code class="docutils literal"><span class="pre">DEFAULT_DISP_NUM</span></code> to reflect this amount:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>uint64_t r = 0;
fdata = (char *)malloc (finfo.st_size);
CHECK_ERROR (fdata == NULL);
while(r &lt; (uint64_t)finfo.st_size)
       r += pread (fd, fdata + r, finfo.st_size, r);
CHECK_ERROR (r != (uint64_t)finfo.st_size);
// Get the number of results to display
CHECK_ERROR((disp_num = (disp_num_str == NULL) ?
             DEFAULT_DISP_NUM : atoi(disp_num_str)) &lt;= 0);
</pre></div>
</div>
<p>Now the magic happens: we run our MapReduce job. This is easily accomplished
in three lines. We first instantiate a <code class="docutils literal"><span class="pre">result</span></code> vector. We instantiate a
mapreduce job with the line:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">WordsMR</span> <span class="n">mapReduce</span><span class="p">(</span><span class="n">fdata</span><span class="p">,</span> <span class="n">finfo</span><span class="o">.</span><span class="n">st_size</span><span class="p">,</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">fdata</span></code> will bind to the data pointer in <code class="docutils literal"><span class="pre">WordsMR</span></code>, <code class="docutils literal"><span class="pre">finfo.st_size</span></code>
will bind to <code class="docutils literal"><span class="pre">data_size</span></code> and <code class="docutils literal"><span class="pre">chunk_size</span></code> wil be set to the quantity
<code class="docutils literal"><span class="pre">1024*1024</span></code>. The following line just ensure the result array is non empty:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CHECK_ERROR</span><span class="p">(</span> <span class="n">mapReduce</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The final part of the code prints out the top <code class="docutils literal"><span class="pre">DEFAULT_DISP_NUM</span></code> entries,
sorted in order of greatest to least count. Since the output of the MapReduce
task is in sorted descending order, it suffices just to print the first
<code class="docutils literal"><span class="pre">DEFAULT_DISP_NUM</span></code> values. A second loop counts the total number of words
found:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">min</span><span class="p">(</span><span class="n">disp_num</span><span class="p">,</span> <span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span><span class="p">)</span><span class="n">result</span><span class="o">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Wordcount: Results (TOP </span><span class="si">%d</span><span class="s2"> of </span><span class="si">%lu</span><span class="s2">):</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dn</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">size</span><span class="p">());</span>
<span class="n">uint64_t</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%15s</span><span class="s2"> - </span><span class="si">%lu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Total: </span><span class="si">%lu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, the <code class="docutils literal"><span class="pre">fdata</span></code> pointer is freed and we end the program:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">free</span> <span class="p">(</span><span class="n">fdata</span><span class="p">);</span>
<span class="n">CHECK_ERROR</span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="running-the-code">
<h2>Running the Code<a class="headerlink" href="#running-the-code" title="Permalink to this headline">¶</a></h2>
<p>We prepared a simplified version of the word count program, <a class="reference external" href="phoenix++-wc.tar.gz">in this archive called phoenix++-wc.tar.gz</a>, which shows what a standalone Phoenix++ application looks like. Alternatively, you can access the official Phoenix++
release at this link. The following instructions assume that you downloaded the
<a class="reference external" href="phoenix++-wc.tar.gz">phoenix++-wc.tar.gz</a> file.</p>
<p>After downloading the file, untar it with the following command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">tar</span> <span class="o">-</span><span class="n">xzvf</span> <span class="n">phoenix</span><span class="o">++-</span><span class="n">wc</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
</pre></div>
</div>
<p>Let&#8217;s look at this folder&#8217;s directory structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">|--</span> <span class="n">data</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">dickens</span><span class="o">.</span><span class="n">txt</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">sherlock</span><span class="o">.</span><span class="n">txt</span>
<span class="o">|--</span> <span class="n">Defines</span><span class="o">.</span><span class="n">mk</span>
<span class="o">|--</span> <span class="n">docs</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="mf">2011.</span><span class="n">phoenixplus</span><span class="o">.</span><span class="n">mapreduce</span><span class="o">.</span><span class="n">pdf</span>
<span class="o">|--</span> <span class="n">include</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">atomic</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">combiner</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">container</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">locality</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">map_reduce</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">processor</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">stddefines</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">synch</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">task_queue</span><span class="o">.</span><span class="n">h</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">thread_pool</span><span class="o">.</span><span class="n">h</span>
<span class="o">|--</span> <span class="n">lib</span>
<span class="o">|--</span> <span class="n">Makefile</span>
<span class="o">|--</span> <span class="n">README</span>
<span class="o">|--</span> <span class="n">src</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">Makefile</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">task_queue</span><span class="o">.</span><span class="n">cpp</span>
<span class="o">|</span>   <span class="o">|--</span> <span class="n">thread_pool</span><span class="o">.</span><span class="n">cpp</span>
<span class="o">|--</span> <span class="n">word_count</span>
    <span class="o">|--</span> <span class="n">Makefile</span>
    <span class="o">|--</span> <span class="n">README</span>
    <span class="o">|--</span> <span class="n">word_count</span><span class="o">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p>The folder <code class="docutils literal"><span class="pre">data</span></code> contains some sample data files for you to play with. The
file <code class="docutils literal"><span class="pre">Defines.mk</span></code> contains many of the compiler flags and other directives
needed to compile our code. The <code class="docutils literal"><span class="pre">docs</span></code> folder contains the Phoenix++ paper
that you can read. The <code class="docutils literal"><span class="pre">include</span></code> folder contains all the header files we need
for our Phoenix++ application. The <code class="docutils literal"><span class="pre">lib</span></code> directory is currently empty; once
we compile our code, it will contain the phoenix++ library file,
<code class="docutils literal"><span class="pre">libphoenix.a</span></code>. The <code class="docutils literal"><span class="pre">src</span></code> folder contains the code needed to make the
Phoenix++ library file. Lastly, our word count application is located in the
directory <code class="docutils literal"><span class="pre">word_count</span></code>.</p>
<dl class="docutils">
<dt>To compile the application, run the <code class="docutils literal"><span class="pre">make</span></code> command in the main Phoenix++-wc</dt>
<dd>directory:</dd>
</dl>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">make</span>
</pre></div>
</div>
<p>Let&#8217;s run the application on the file <code class="docutils literal"><span class="pre">dickens.txt</span></code>. This file is 21MB, and
contains the collective works of Charles Dickens. Run the application with the
following command:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">time</span> <span class="o">-</span><span class="n">p</span> <span class="o">./</span><span class="n">word_count</span><span class="o">/</span><span class="n">word_count</span> <span class="n">data</span><span class="o">/</span><span class="n">dickens</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>This will show you the top 10 most frequent words detected in <code class="docutils literal"><span class="pre">dickens.txt</span></code>.
To see detailed timing information, uncomment the line <code class="docutils literal"><span class="pre">#define</span> <span class="pre">TIMING</span></code> in
<code class="docutils literal"><span class="pre">include/stddefines.h</span></code>.</p>
<p>Below you will find a series of exercises to explore the example further.
Happy analyzing!</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s explore the <code class="docutils literal"><span class="pre">word_count.cpp</span></code> file a bit futher by modifying it slightly.
Remember, every time you change this file, you must recompile your code using
the <code class="docutils literal"><span class="pre">make</span></code> command!</p>
<ul class="simple">
<li>Run the word count program to print the top 20 words, the top 50 words, and
the top 100 words. How does the run-time change?</li>
<li>Most of the words that have been showing up are common short words, such as
&#8220;and&#8221;, &#8220;the&#8221;, &#8220;of&#8221;, &#8220;in&#8221;, and &#8220;a&#8221;. Modify the <code class="docutils literal"><span class="pre">map()</span></code> function to only
print out words that are five characters or longer. What are the top ten
words now? How does Charles Dickens&#8217; top 10 words differ from Arthur Conan
Doyle&#8217;s?</li>
<li>Use the setenv command to set the <code class="docutils literal"><span class="pre">MR_NUMTHREADS</span></code> environmental variable to
a user inutted number of threads in <code class="docutils literal"><span class="pre">main.cpp</span></code>. Check the setenv
documentation for more details.</li>
<li>Check the number of CPU cores on your machine by checking <code class="docutils literal"><span class="pre">/proc/cpuinfo</span></code>.
Vary the number of threads from <em>1...c</em> where <em>c</em> is the number of CPU cores.
Plot your timing results using Matplotlib.</li>
<li><em>Challenge</em>: The words that are showing up are still those that largely
reflect the grammar of an author&#8217;s writing. These are known as function words.
Modify the <code class="docutils literal"><span class="pre">map()</span></code> function to <em>exclude</em> any words that are function words.
A list of 321 common function words can be found at this link.</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/CSInParallel200wide.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting Started with Phoenix++</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#wordsmr-the-word-count-class">WordsMR: The word count class</a><ul>
<li><a class="reference internal" href="#the-locate-function">The locate() function</a></li>
<li><a class="reference internal" href="#the-map-function">The map() function</a></li>
<li><a class="reference internal" href="#the-split-function">The split() function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-main-function">The main() function</a></li>
<li><a class="reference internal" href="#running-the-code">Running the Code</a></li>
<li><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../wordcount/wordcount.html"
                        title="previous chapter">Counting Pease With MapReduce</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../wordcount/wordcount.html" title="Counting Pease With MapReduce"
             >previous</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">MapReduce with Pheonix++</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Suzanne J. Matthews.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.1.
    </div>
  </body>
</html>