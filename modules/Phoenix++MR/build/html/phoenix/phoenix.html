<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting Started with Phoenix++ &mdash; Introducing Students to MapReduce with Phoenix++ 1 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Introducing Students to MapReduce with Phoenix++ 1 documentation" href="../index.html" />
    <link rel="prev" title="Counting Pease With MapReduce" href="../wordcount/wordcount.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../wordcount/wordcount.html" title="Counting Pease With MapReduce"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Introducing Students to MapReduce with Phoenix++ 1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="getting-started-with-phoenix">
<h1>Getting Started with Phoenix++<a class="headerlink" href="#getting-started-with-phoenix" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will discuss the Phoenix++ wordcount example in detail. You
will need a basic knowledge of C/C++ to follow along with these concepts. You
can download a copy of the Phoenix++ word count example
:<tt class="xref download docutils literal"><span class="pre">here</span></tt>. We will start by looking at the file
<tt class="docutils literal"><span class="pre">word_count.cpp</span></tt>. At the top of the file, there are three structs we should
pay attention to:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">// a passage from the text. The input data to the Map-Reduce</span>
<span class="k">struct</span> <span class="n">wc_string</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// a single null-terminated word</span>
<span class="k">struct</span> <span class="n">wc_word</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

    <span class="c1">// necessary functions to use this as a key</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">wc_word</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">wc_word</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// a hash for the word</span>
<span class="k">struct</span> <span class="n">wc_word_hash</span>
<span class="p">{</span>
    <span class="c1">// FNV-1a hash for 64 bits</span>
    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="n">wc_word</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">14695981039346656037ULL</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">h</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">^</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">++</span><span class="p">)))</span> <span class="o">*</span> <span class="mi">1099511628211ULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>These three structs define the type of our input chunk (<tt class="docutils literal"><span class="pre">wc_string</span></tt>), our keys
(<tt class="docutils literal"><span class="pre">wc_word</span></tt>) and the hash function that we are going to use to aggregate
common keys (<tt class="docutils literal"><span class="pre">wc_word_hash</span></tt>). The <tt class="docutils literal"><span class="pre">wc_string</span></tt> struct has a data pointer
field  (which points to to the start of the chunk), and a <tt class="docutils literal"><span class="pre">len</span></tt> field which
indicates the size of the chunk. The <tt class="docutils literal"><span class="pre">wc_word</span></tt> struct contains only a
pointer to the start of a word, along with the defintions on how to compare
two &#8220;words&#8221;. At this point, you may be asking yourself, <em>but, how do you know
where a word ends?</em> Be patient; when we get to the main body of code, it will
all become clear. The last struct contains only an operator definition for <tt class="docutils literal"><span class="pre">()</span></tt>,
which requires a key of type <tt class="docutils literal"><span class="pre">wc_count</span></tt> as its single parameter. This is an
implementation of the Fowler-Noll-Vo hash function. While other hash functions
can be used, it is best just to leave this code alone.</p>
</div>
<div class="section" id="wordsmr-the-word-count-class">
<h2>WordsMR: The word count class<a class="headerlink" href="#wordsmr-the-word-count-class" title="Permalink to this headline">¶</a></h2>
<p>For every application you write using Phoenix++, you will need to define a
class for it. Let&#8217;s start by taking a look at the class header:</p>
<p>::
class WordsMR : public MapReduceSort&lt;WordsMR, wc_string, wc_word, uint64_t, hash_container&lt;wc_word, uint64_t, sum_combiner, wc_word_hash&gt; &gt;</p>
<p>The first thing to note about this definition is that <tt class="docutils literal"><span class="pre">WordsMR</span></tt> is derived
from class <tt class="docutils literal"><span class="pre">MapReduceSort</span></tt>, which is defined in <tt class="docutils literal"><span class="pre">mapreduce.h</span></tt>. This is the
primary beauty of Phoenix++; to write your own MapReduce programs, you simply
overload the default function defined in the base class. We define the class
with the following parameters (in order):</p>
<ul class="simple">
<li>the implemented class type (<a href="#id1"><span class="problematic" id="id2">*</span></a>Impl*=``WordsMR``)</li>
<li>the input data type (<a href="#id3"><span class="problematic" id="id4">*</span></a>D*=``wc_string``)</li>
<li>the key type (<a href="#id5"><span class="problematic" id="id6">*</span></a>K*=``wc_word``)</li>
<li>the value type (<a href="#id7"><span class="problematic" id="id8">*</span></a>V*=``uint_64``)</li>
<li>the definition of the hash container (<tt class="docutils literal"><span class="pre">hash_container&lt;...&gt;</span></tt>)</li>
</ul>
<p><tt class="docutils literal"><span class="pre">hash_container</span></tt> defines the parameters for the hashtable used to aggregate
<em>(key, value)</em> pairs. A full definition of the <tt class="docutils literal"><span class="pre">hash_container</span></tt> class can be
found in <tt class="docutils literal"><span class="pre">container.h</span></tt>. It&#8217;s input parameters are:</p>
<ul class="simple">
<li>the key type (<a href="#id9"><span class="problematic" id="id10">*</span></a>K*=``wc_word``)</li>
<li>the value type (<a href="#id11"><span class="problematic" id="id12">*</span></a>V*=``uint_64``)</li>
<li>the type of combiner function (<a href="#id13"><span class="problematic" id="id14">*</span></a>Combiner*=``sum_combiner``)</li>
<li>The hash function to use (<a href="#id15"><span class="problematic" id="id16">*</span></a>hash*=``wc_word_hash``)</li>
</ul>
<p>Note the use of the combiner <tt class="docutils literal"><span class="pre">sum_combiner</span></tt>, an associative combiner
implemented in Phoenix++. This means, as collisions in our hash table occur,
the values are added together. This actually eliminates the need for a reduce
function in our application! The other type of combiner is known as the
<tt class="docutils literal"><span class="pre">buffer_combiner</span></tt>, and reflects typical MapReduce behavior. This combiner
chains all the values together. The functions shown below are ones that are
commonly overloaded when creating a Phoenix++ MapReduce class:</p>
<p>+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
| Function Name      |                    Description                     |
+====================+====================================================+
<a href="#id53"><span class="problematic" id="id54">|``map()``           |Defines the functionality for map tasks. The default|</span></a>
|                    <a href="#id17"><span class="problematic" id="id18">|</span></a>definition of the <tt class="docutils literal"><span class="pre">map()</span></tt> function is empty. This |
|                    <a href="#id19"><span class="problematic" id="id20">|</span></a>function must be overloaded for every user-defined  |
|                    <a href="#id21"><span class="problematic" id="id22">|</span></a>MapReduce class.                                    |
+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-+
<a href="#id23"><span class="problematic" id="id24">|</span></a><tt class="docutils literal"><span class="pre">reduce()</span></tt>        <a href="#id25"><span class="problematic" id="id26">|</span></a>Defines the functionality for the reduce tasks. By  |
|                    <a href="#id27"><span class="problematic" id="id28">|</span></a>default, the <tt class="docutils literal"><span class="pre">reduce()</span></tt> function generates a list |
|                    <a href="#id29"><span class="problematic" id="id30">|</span></a>of <em>(key,value)</em> pairs from a given key and         |
|                    <a href="#id31"><span class="problematic" id="id32">|</span></a><em>list(value)</em> input.                                |
+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-+
<a href="#id33"><span class="problematic" id="id34">|</span></a><tt class="docutils literal"><span class="pre">split()</span></tt>         <a href="#id35"><span class="problematic" id="id36">|</span></a>Defines how input data should be chunked. The       |
|                    <a href="#id37"><span class="problematic" id="id38">|</span></a>default <tt class="docutils literal"><span class="pre">split()</span></tt> function returns <tt class="docutils literal"><span class="pre">0</span></tt>. This    |
|                    <a href="#id39"><span class="problematic" id="id40">|</span></a>function must be overloaded for every user-defined  |
|                    <a href="#id41"><span class="problematic" id="id42">|</span></a>MapReduce class.                                    |
+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-+
<a href="#id43"><span class="problematic" id="id44">|</span></a><tt class="docutils literal"><span class="pre">locate()</span></tt>        <a href="#id45"><span class="problematic" id="id46">|</span></a>Indicates where to access the input data from. By   |
|                    <a href="#id47"><span class="problematic" id="id48">|</span></a>default, the <tt class="docutils literal"><span class="pre">locate()</span></tt> function casts the input  |
|                    <a href="#id49"><span class="problematic" id="id50">|</span></a>data as a void pointer.                             |
+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;+&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-+</p>
<p>For the word count application, the <tt class="docutils literal"><span class="pre">map()</span></tt>, <tt class="docutils literal"><span class="pre">locate()</span></tt> and <tt class="docutils literal"><span class="pre">split()</span></tt>
functions are overloaded as public methods.</p>
<p>The class declares a number of global variables, that will be initialized by
user input:</p>
<p>::
char* data;
uint64_t data_size;
uint64_t chunk_size;
uint64_t splitter_pos;</p>
<p>We can see these values getting initialized in the constructor below.</p>
<p>::
explicit WordsMR(char* _data, uint64_t length, uint64_t _chunk_size) :</p>
<blockquote>
<div><dl class="docutils">
<dt>data(_data), data_size(length), chunk_size(_chunk_size),</dt>
<dd>splitter_pos(0) {}</dd>
</dl>
</div></blockquote>
<div class="section" id="the-locate-function">
<h3>The locate() function<a class="headerlink" href="#the-locate-function" title="Permalink to this headline">¶</a></h3>
<p>The first function declared in the public scope of the class is <tt class="docutils literal"><span class="pre">locate()</span></tt>:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>    <span class="kt">void</span><span class="o">*</span> <span class="n">locate</span><span class="p">(</span><span class="n">data_type</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">len</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">str</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">locate()</span></tt> function takes two parameters: a pointer to the input data
type (<tt class="docutils literal"><span class="pre">data_type*</span></tt>), and a length (<tt class="docutils literal"><span class="pre">len</span></tt>). It returns a pointer to the
start of readable data. In this case, it will be the data field of the
<tt class="docutils literal"><span class="pre">wc_string</span></tt> struct, which is our input data type.</p>
</div>
<div class="section" id="the-map-function">
<h3>The map() function<a class="headerlink" href="#the-map-function" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">map()</span></tt> function is declared next. Its two parameters is the input data
type (passed by reference), and the ouput data container (<tt class="docutils literal"><span class="pre">out</span></tt>). Remember,
our input data type is <tt class="docutils literal"><span class="pre">wc_string</span></tt>. Remember that <tt class="docutils literal"><span class="pre">wc_string</span></tt> is a struct
with two fields: <tt class="docutils literal"><span class="pre">data</span></tt> and <tt class="docutils literal"><span class="pre">len</span></tt>. The input represents a &#8220;chunk&#8221; of data
which we want to parse words from and emit <em>(key,value)</em> pairs associating each
word with the count of <tt class="docutils literal"><span class="pre">1</span></tt>:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre>    <span class="kt">void</span> <span class="n">map</span><span class="p">(</span><span class="n">data_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="n">map_container</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">toupper</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
        <span class="p">{</span>            
            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;A&#39;</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;Z&#39;</span><span class="p">))</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="kt">uint64_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;Z&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\&#39;&#39;</span><span class="p">))</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">wc_word</span> <span class="n">word</span> <span class="o">=</span> <span class="p">{</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="o">+</span><span class="n">start</span> <span class="p">};</span>
                <span class="n">emit_intermediate</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The first four lines of the function converts every character in the input
chunk to uppercase. The function <tt class="docutils literal"><span class="pre">toupper</span></tt> is declared in the standard header
file <tt class="docutils literal"><span class="pre">cctype.h</span></tt>. This is to ensure the word count application ignores case
as it counts words.</p>
<p>The while code block contains the majority of the work . It contains two inner
while loops and an if statement.</p>
<ul class="simple">
<li>The first inner while loop determines the starting point of the word. It
skips any characters that are outside the ASCII range of A to Z. As soon as
it exceeds the length of the string or hits an alphabetic character, it stops
incrementing <tt class="docutils literal"><span class="pre">i</span></tt>. This value of <tt class="docutils literal"><span class="pre">i</span></tt> is designated as the start of the
word (<tt class="docutils literal"><span class="pre">start</span> <span class="pre">=</span> <span class="pre">i</span></tt>).</li>
<li>The second inner while loop determines the end of a word. It keeps
incrementing <tt class="docutils literal"><span class="pre">i</span></tt>, so long as the current character is alphabetic, and the
value of <tt class="docutils literal"><span class="pre">i</span></tt> is less than the length of the input chunk. The variable <tt class="docutils literal"><span class="pre">i</span></tt>
stops incrementing once we hit a non-alphebetic character or the end of the
input chunk.</li>
</ul>
<p>The next few line of code is crucial to understanding how the word count
applicaton works:</p>
<p>::
s.data[i] = 0;
wc_word word = { s.data+start };
emit_intermediate(out, word, 1);</p>
<p>Recall that <tt class="docutils literal"><span class="pre">0</span></tt> is the integer value of <tt class="docutils literal"><span class="pre">\0</span></tt>, the null terminator, which
indicates where a string should be terminated. We define our key data
(<tt class="docutils literal"><span class="pre">wc_word</span> <span class="pre">word</span></tt>) to be a pointer to our input chunk, at offset <tt class="docutils literal"><span class="pre">start</span></tt>.
Next, we emit the word key with the value <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>The above process repeats until all the valid words in the input chunk are
consumed.</p>
</div>
<div class="section" id="the-split-function">
<h3>The split() function<a class="headerlink" href="#the-split-function" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">split()</span></tt> function tokenizes the input prior to its going to the <tt class="docutils literal"><span class="pre">map()</span></tt>
function:</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></div></td><td class="code"><div class="highlight"><pre>    <span class="cm">/** wordcount split()</span>
<span class="cm">     *  Memory map the file and divide file on a word border i.e. a space.</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="nf">split</span><span class="p">(</span><span class="n">wc_string</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* End of data reached, return FALSE. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">splitter_pos</span> <span class="o">&gt;=</span> <span class="n">data_size</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Determine the nominal end point. */</span>
        <span class="kt">uint64_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">splitter_pos</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>

        <span class="cm">/* Move end point to next word break */</span>
        <span class="k">while</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">data_size</span> <span class="o">&amp;&amp;</span> 
            <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\t&#39;</span> <span class="o">&amp;&amp;</span>
            <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="n">end</span><span class="o">++</span><span class="p">;</span>

        <span class="cm">/* Set the start of the next data. */</span>
        <span class="n">out</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="n">splitter_pos</span><span class="p">;</span>
        <span class="n">out</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">splitter_pos</span><span class="p">;</span>
        
        <span class="n">splitter_pos</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

        <span class="cm">/* Return true since the out data is valid. */</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">sort</span><span class="p">(</span><span class="n">keyval</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">keyval</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span> <span class="o">||</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Keep in mind while reading this code that the input file is in shared memory.
The function takes a single parameter, a reference to a <tt class="docutils literal"><span class="pre">wc_string</span></tt> object,
which is our input data type. Recall that the variables <tt class="docutils literal"><span class="pre">splitter_pos</span></tt> and
<tt class="docutils literal"><span class="pre">data_size</span></tt> are global. The variable <tt class="docutils literal"><span class="pre">splitter_pos</span></tt> tells us where we are
currently in the file. The variable <tt class="docutils literal"><span class="pre">data_size</span></tt> represents the size of the
entire file. The variable <tt class="docutils literal"><span class="pre">chunk_size</span></tt> represents the size of each chunk.</p>
<ul class="simple">
<li>The first if statement simply ensures that our current position does not</li>
</ul>
<p>exceed the bounds of the file. If so, we exit the function by returning 0
(indicating failure, and that there is nothing more to split).</p>
<p>We want each chunk to be approximately the same. We first determine a
&#8220;nominal&#8221; end-point, or position to &#8220;chunk&#8221; the data:</p>
<p>::
uint64_t end = std::min(splitter_pos + chunk_size, data_size);</p>
<p>Obviously, this end-point won&#8217;t always work. What if we land in the middle of a
word? Therefore, we want to increment <tt class="docutils literal"><span class="pre">end</span></tt> until we hit a natural word
boundry. The <tt class="docutils literal"><span class="pre">split()</span></tt> function declares this boundry as being either a
space, tab, return carriage, or new line character. This is achieved by the
following code:
::
while(end &lt; data_size &amp;&amp;</p>
<blockquote>
<div>data[end] != &#8216; &#8216; &amp;&amp; data[end] != &#8216;t&#8217; &amp;&amp;
data[end] != &#8216;r&#8217; &amp;&amp; data[end] != &#8216;n&#8217;)
end++;</div></blockquote>
<p>Once we determine a valid end-point, we populate the inputted <tt class="docutils literal"><span class="pre">wc_string</span></tt>
object:</p>
<p>::
out.data = data + splitter_pos;
out.len = end - splitter_pos;</p>
<p>The starting point is set to data pointer plus the starting value of
<tt class="docutils literal"><span class="pre">splitter_pos</span></tt>. The length is determined by subtracting <tt class="docutils literal"><span class="pre">end</span></tt> from
<tt class="docutils literal"><span class="pre">splitter_pos</span></tt>.</p>
<p>Finally, we update <tt class="docutils literal"><span class="pre">splitter_pos</span></tt> to be the end point (<tt class="docutils literal"><span class="pre">end</span></tt>), and return
<tt class="docutils literal"><span class="pre">1</span></tt> to indicate that we were able to successfully split the input.</p>
</div>
</div>
<div class="section" id="the-main-function">
<h2>The main() function<a class="headerlink" href="#the-main-function" title="Permalink to this headline">¶</a></h2>
<p>A simplified version of the <tt class="docutils literal"><span class="pre">main()</span></tt> function is shown below. This version
only shows the non memory mapped code. The memory mapped version of the code
can be viewed here. We also remove timing code for simplicity. The
<tt class="docutils literal"><span class="pre">CHECK_ERROR</span></tt> function is defined in the file <tt class="docutils literal"><span class="pre">stddefines.h</span></tt> and is a
useful wrapper for error handling.</p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88</pre></div></td><td class="code"><div class="highlight"><pre>int main(int argc, char *argv[]) 
{
    int fd;
    char * fdata;
    unsigned int disp_num;
    struct stat finfo;
    char * fname, * disp_num_str;
    struct timespec begin, end;

    get_time (begin);

    // Make sure a filename is specified
    if (argv[1] == NULL)
    {
        printf(&quot;USAGE: %s &lt;filename&gt; [Top # of results to display]\n&quot;, argv[0]);
        exit(1);
    }

    fname = argv[1];
    disp_num_str = argv[2];

    printf(&quot;Wordcount: Running...\n&quot;);

    // Read in the file
    CHECK_ERROR((fd = open(fname, O_RDONLY)) &lt; 0);
    // Get the file info (for file length)
    CHECK_ERROR(fstat(fd, &amp;finfo) &lt; 0);

    uint64_t r = 0;

    fdata = (char *)malloc (finfo.st_size);
    CHECK_ERROR (fdata == NULL);
    while(r &lt; (uint64_t)finfo.st_size)
        r += pread (fd, fdata + r, finfo.st_size, r);
    CHECK_ERROR (r != (uint64_t)finfo.st_size);

    
    // Get the number of results to display
    CHECK_ERROR((disp_num = (disp_num_str == NULL) ? 
      DEFAULT_DISP_NUM : atoi(disp_num_str)) &lt;= 0);

    get_time (end);

    #ifdef TIMING
    print_time(&quot;initialize&quot;, begin, end);
    #endif

    printf(&quot;Wordcount: Calling MapReduce Scheduler Wordcount\n&quot;);
    get_time (begin);
    std::vector&lt;WordsMR::keyval&gt; result;    
    WordsMR mapReduce(fdata, finfo.st_size, 1024*1024);
    CHECK_ERROR( mapReduce.run(result) &lt; 0);
    get_time (end);

    #ifdef TIMING
    print_time(&quot;library&quot;, begin, end);
    #endif
    printf(&quot;Wordcount: MapReduce Completed\n&quot;);

    get_time (begin);

    unsigned int dn = std::min(disp_num, (unsigned int)result.size());
    printf(&quot;\nWordcount: Results (TOP %d of %lu):\n&quot;, dn, result.size());
    uint64_t total = 0;
    for (size_t i = 0; i &lt; dn; i++)
    {
        printf(&quot;%15s - %lu\n&quot;, result[result.size()-1-i].key.data, result[result.size()-1-i].val);
    }

    for(size_t i = 0; i &lt; result.size(); i++)
    {
        total += result[i].val;
    }

    printf(&quot;Total: %lu\n&quot;, total);

    free (fdata);

    CHECK_ERROR(close(fd) &lt; 0);

    get_time (end);

    #ifdef TIMING
    print_time(&quot;finalize&quot;, begin, end);
    #endif

    return 0;
}
</pre></div>
</td></tr></table></div>
<p>We analyze this code in parts:</p>
<p>In the first part, we are simply setting up variables. Users running the
program are required to input a file, and may choose to specify the top number
of results to display. Variables are declared to facillitate file reading and
command line parsing:</p>
<p>::
int fd;
char * fdata;
unsigned int disp_num;
struct stat finfo;
char * fname, * disp_num_str;
// Make sure a filename is specified
if (argv[1] == NULL)</p>
<blockquote>
<div><dl class="docutils">
<dt>{</dt>
<dd><dl class="first last docutils">
<dt>printf(&#8220;USAGE: %s  [Top # of results to display]n&#8221;, argv[0]);</dt>
<dd>exit(1);</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>fname = argv[1];
disp_num_str = argv[2];</p>
<p>We next open the file for reading, and get its size using the <tt class="docutils literal"><span class="pre">fstat</span></tt> function.
We <tt class="docutils literal"><span class="pre">malloc()</span></tt> a block of memory, and have the descriptor <tt class="docutils literal"><span class="pre">fdata</span></tt> point to
it. Next, we read the file into memory using the <tt class="docutils literal"><span class="pre">pread()</span></tt> system call. We
also check to see if the user inputted the optional parameter that sets the
maximum number of entries to display. If so, we update the variable
<tt class="docutils literal"><span class="pre">DEFAULT_DISP_NUM</span></tt> to reflect this amount:</p>
<p>::
uint64_t r = 0;
fdata = (char <a href="#id51"><span class="problematic" id="id52">*</span></a>)malloc (finfo.st_size);
CHECK_ERROR (fdata == NULL);
while(r &lt; (uint64_t)finfo.st_size)</p>
<blockquote>
<div>r += pread (fd, fdata + r, finfo.st_size, r);</div></blockquote>
<p>CHECK_ERROR (r != (uint64_t)finfo.st_size);
// Get the number of results to display
CHECK_ERROR((disp_num = (disp_num_str == NULL) ?</p>
<blockquote>
<div>DEFAULT_DISP_NUM : atoi(disp_num_str)) &lt;= 0);</div></blockquote>
<p>Now the magic happens: we run our MapReduce job. This is easily accomplished
in three lines. We first instantiate a <tt class="docutils literal"><span class="pre">result</span></tt> vector. We instantiate a
mapreduce job with the line:</p>
<p>::
WordsMR mapReduce(fdata, finfo.st_size, 1024*1024);</p>
<p>Here, <tt class="docutils literal"><span class="pre">fdata</span></tt> will bind to the data pointer in <tt class="docutils literal"><span class="pre">WordsMR</span></tt>, <tt class="docutils literal"><span class="pre">finfo.st_size</span></tt>
will bind to <tt class="docutils literal"><span class="pre">data_size</span></tt> and <tt class="docutils literal"><span class="pre">chunk_size</span></tt> wil be set to the quantity
<tt class="docutils literal"><span class="pre">1024*1024</span></tt>. The following line just ensure the result array is non empty:</p>
<p>::
CHECK_ERROR( mapReduce.run(result) &lt; 0);</p>
<p>The final part of the code prints out the top <tt class="docutils literal"><span class="pre">DEFAULT_DISP_NUM</span></tt> entries,
sorted in order of greatest to least count. Since the output of the MapReduce
task is in sorted descending order, it suffices just to print the first
<tt class="docutils literal"><span class="pre">DEFAULT_DISP_NUM</span></tt> values. A second loop counts the total number of words
found:
::
unsigned int dn = std::min(disp_num, (unsigned int)result.size());
printf(&#8220;nWordcount: Results (TOP %d of %lu):n&#8221;, dn, result.size());
uint64_t total = 0;
for (size_t i = 0; i &lt; dn; i++)
{</p>
<blockquote>
<div>printf(&#8220;%15s - %lun&#8221;, result[result.size()-1-i].key.data, result[result.size()-1-i].val);</div></blockquote>
<p>}
for (size_t i = 0; i &lt; result.size(); i++)
{</p>
<blockquote>
<div>total += result[i].val;</div></blockquote>
<p>}
printf(&#8220;Total: %lun&#8221;, total);</p>
<p>Finally, the <tt class="docutils literal"><span class="pre">fdata</span></tt> pointer is freed and we end the program:</p>
<p>::
free (fdata);
CHECK_ERROR(close(fd) &lt; 0);
return 0;</p>
</div>
<div class="section" id="running-the-code">
<h2>Running the Code<a class="headerlink" href="#running-the-code" title="Permalink to this headline">¶</a></h2>
<p>We prepared a simplified version of the word count program,
::download`here&lt;phoenix++-wc.tar.gz&gt;`, which shows what a standalone Phoenix++
application looks like. Alternatively, you can access the official Phoenix++
release at this link. The following instructions assume that you downloaded the
<cite>phoenix++-wc.tar.gz</cite> file.</p>
<p>After downloading the file, untar it with the following command:</p>
<p>::
tar -xzvf phoenix++-wc.tar.gz</p>
<p>Let&#8217;s look at this folder&#8217;s directory structure:</p>
<p>::
├── data
│&nbsp;&nbsp; ├── dickens.txt
│&nbsp;&nbsp; └── sherlock.txt
├── Defines.mk
├── docs
│&nbsp;&nbsp; └── 2011.phoenixplus.mapreduce.pdf
├── include
│&nbsp;&nbsp; ├── atomic.h
│&nbsp;&nbsp; ├── combiner.h
│&nbsp;&nbsp; ├── container.h
│&nbsp;&nbsp; ├── locality.h
│&nbsp;&nbsp; ├── map_reduce.h
│&nbsp;&nbsp; ├── processor.h
│&nbsp;&nbsp; ├── scheduler.h
│&nbsp;&nbsp; ├── stddefines.h
│&nbsp;&nbsp; ├── synch.h
│&nbsp;&nbsp; ├── task_queue.h
│&nbsp;&nbsp; └── thread_pool.h
├── lib
├── Makefile
├── README
├── src
│&nbsp;&nbsp; ├── Makefile
│&nbsp;&nbsp; ├── task_queue.cpp
│&nbsp;&nbsp; └── thread_pool.cpp
└── word_count</p>
<blockquote>
<div>├── Makefile
├── README
├── word_count.cpp</div></blockquote>
<p>The folder <tt class="docutils literal"><span class="pre">data</span></tt> contains some sample data files for you to play with. The
file <tt class="docutils literal"><span class="pre">Defines.mk</span></tt> contains many of the compiler flags and other directives
needed to compile our code. The <tt class="docutils literal"><span class="pre">docs</span></tt> folder contains the Phoenix++ paper
that you can read. The <tt class="docutils literal"><span class="pre">include</span></tt> folder contains all the header files we need
for our Phoenix++ application. The <tt class="docutils literal"><span class="pre">lib</span></tt> directory is currently empty; once
we compile our code, it will contain the phoenix++ library file,
<tt class="docutils literal"><span class="pre">libphoenix.a</span></tt>. The <tt class="docutils literal"><span class="pre">src</span></tt> folder contains the code needed to make the
Phoenix++ library file. Lastly, our word count application is located in the
directory <tt class="docutils literal"><span class="pre">word_count</span></tt>.</p>
<dl class="docutils">
<dt>To compile the application, run the <tt class="docutils literal"><span class="pre">make</span></tt> command in the main Phoenix++-wc</dt>
<dd>directory:</dd>
</dl>
<p>::
make</p>
<p>Let&#8217;s run the application on the file <tt class="docutils literal"><span class="pre">dickens.txt</span></tt>. This file is 21MB, and
contains the collective works of Charles Dickens. Run the application with the
following command:</p>
<p>::
time -p ./word_count/word_count data/dickens.txt</p>
<p>This will show you the top 10 most frequent words detected in <tt class="docutils literal"><span class="pre">dickens.txt</span></tt>.
To see detailed timing information, uncomment the line <tt class="docutils literal"><span class="pre">#define</span> <span class="pre">TIMING</span></tt> in
<tt class="docutils literal"><span class="pre">include/stddefines.h</span></tt>.</p>
<p>Below you will find a series of exercises to explore the example further.
Happy analyzing!</p>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s explore the <tt class="docutils literal"><span class="pre">word_count.cpp</span></tt> file a bit futher by modifying it slightly.
Remember, every time you change this file, you must recompile your code using
the <tt class="docutils literal"><span class="pre">make</span></tt> command!</p>
<ul class="simple">
<li>Run the word count program to print the top 20 words, the top 50 words, and
the top 100 words. How does the run-time change?</li>
<li>Most of the words that have been showing up are common short words, such as
&#8220;and&#8221;, &#8220;the&#8221;, &#8220;of&#8221;, &#8220;in&#8221;, and &#8220;a&#8221;. Modify the <tt class="docutils literal"><span class="pre">map()</span></tt> function to only
print out words that are five characters or longer. What are the top ten
words now? How does Charles Dickens&#8217; top 10 words differ from Arthur Conan
Doyle&#8217;s?</li>
<li>Use the setenv command to set the <tt class="docutils literal"><span class="pre">MR_NUMTHREADS</span></tt> environmental variable to
a user inutted number of threads in <tt class="docutils literal"><span class="pre">main.cpp</span></tt>. Check the setenv
documentation for more details.</li>
<li>Check the number of CPU cores on your machine by checking <tt class="docutils literal"><span class="pre">/proc/cpuinfo</span></tt>.
Vary the number of threads from <em>1...c</em> where <em>c</em> is the number of CPU cores.
Plot your timing results using Matplotlib.</li>
<li><em>Challenge</em>: The words that are showing up are still those that largely
reflect the grammar of an author&#8217;s writing. These are known as function words.
Modify the <tt class="docutils literal"><span class="pre">map()</span></tt> function to <em>exclude</em> any words that are function words.
A list of 321 common function words can be found at this link.</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting Started with Phoenix++</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#wordsmr-the-word-count-class">WordsMR: The word count class</a><ul>
<li><a class="reference internal" href="#the-locate-function">The locate() function</a></li>
<li><a class="reference internal" href="#the-map-function">The map() function</a></li>
<li><a class="reference internal" href="#the-split-function">The split() function</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-main-function">The main() function</a></li>
<li><a class="reference internal" href="#running-the-code">Running the Code</a></li>
<li><a class="reference internal" href="#exercises">Exercises</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../wordcount/wordcount.html"
                        title="previous chapter">Counting Pease With MapReduce</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/phoenix/phoenix.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../wordcount/wordcount.html" title="Counting Pease With MapReduce"
             >previous</a> |</li>
        <li><a href="../index.html">Introducing Students to MapReduce with Phoenix++ 1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2016, Suzanne J. Matthews.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>