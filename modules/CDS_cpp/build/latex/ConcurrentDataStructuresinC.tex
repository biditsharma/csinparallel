% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Concurrent Data Structures in C++ Documentation}
\date{July 11, 2012}
\release{}
\author{CSInParallel Project}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Concurrent Data Structures in C++: Web crawler lab}
\label{WebCrawler/CDS_crawler_lab_cpp::doc}\label{WebCrawler/CDS_crawler_lab_cpp:concurrent-data-structures-in-c-web-crawler-lab}\label{WebCrawler/CDS_crawler_lab_cpp:concurrent-data-structures-in-c}
In this lab you will complete some code provided to you that will `crawl' the web from a beginning page to a given depth by following every linked page and scraping it for more links to follow.  The links found on each page are kept in a data structure until they are processed.


\section{Your goals}
\label{WebCrawler/CDS_crawler_lab_cpp:your-goals}
The goals for this lab are:
\begin{itemize}
\item {} 
complete and test a web crawler application, which fetches web pages then visits the links contained in those web pages, using STL containers;

\item {} 
experiment with an example of threads programming, a type of multicore parallel programming;

\item {} 
to complete a correct multi-threaded web crawler application that uses threaded building block (TBB) containers.

\end{itemize}


\section{Source Code}
\label{WebCrawler/CDS_crawler_lab_cpp:source-code}\setbox0\vbox{
\begin{minipage}{0.95\linewidth}
\textbf{Still need}

\medskip


The work on this lab requires a ``tarball'' named \code{cds.tar.gz}.

Instructors, please contact us for the complete code.
\end{minipage}}
\begin{center}\setlength{\fboxsep}{5pt}\shadowbox{\box0}\end{center}


\section{Packages needed}
\label{WebCrawler/CDS_crawler_lab_cpp:packages-needed}\begin{itemize}
\item {} 
C++ compiler

\item {} 
Standard Template Library STL

\item {} 
CURL library for web access

\item {} 
Boost library, for threads and mutexes

\item {} 
Intel's Threading Building Blocks (TBB)

\item {} 
Make program

\end{itemize}


\section{Preparation}
\label{WebCrawler/CDS_crawler_lab_cpp:preparation}
Copy the tarball into your directory on a multicore linux machine.  Then `unxip' and `untar' it like this:
\begin{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\% tar xfz cds.tar.gz
\end{Verbatim}

This will create a directory \code{cds} that contains the code. Change
to that directory.

\begin{Verbatim}[commandchars=\\\{\}]
\% cd cds
\end{Verbatim}
\end{quote}


\section{To Do}
\label{WebCrawler/CDS_crawler_lab_cpp:to-do}\begin{enumerate}
\item {} 
The directory \code{serial} contains several subdirectories, and is
organized in a structure suitable for a software project that is
capable of growing very large.

Examine the code for this program. Observe the following:
\begin{itemize}
\item {} 
The source files (\code{.cpp} implementation and driver modules) are
contained in a subdirectory named \code{src}, and the header files
(interface modules) are named with \code{.hcc} and are stored in a
subdirectory named \code{include}.

\item {} 
Some of the state variables in classes within \code{serial} are STL
containers, as described in \href{http://serc.carleton.edu/files/csinparallel/sigcse\_demos/introduction\_stl\_containers.doc}{a class
handout}.

\item {} 
Three classes are defined:
\begin{itemize}
\item {} 
\code{spider} is the main class, with methods for crawling from
page to page and for processing each page, and state variables
for recording the work to be done (i.e., web addresses or
\emph{URLs} of pages to visit), the finished work (URLs already
processes), and a \code{vector} of \code{page} objects.

\item {} 
\code{page} contains state variables for the URL of a particular
web page (as a \code{string}) and a \code{vector} of URLs found in
that web page (which are candidates for future processing).
\code{page} also contains a method for scanning a web page and
filling that \code{vector} with URLs that are contained in that
page.

\item {} 
\code{raw\_page} has helper methods for fetching pages from the web
and for delivering the HTML code from a fetched web page.

\end{itemize}

\item {} 
The main program is in the file \code{spider\_driver.cpp}. It obtains
two values from the command line, namely the starting URL to crawl
from, and the maximum number of URLs to visit (which must be
\emph{parsed} from a string to an integer). Then, the program performs
the crawl and prints results.

\item {} 
The \code{Makefile} uses \code{make} variables to make it easier to
change items such as compilation flags. Source files in the
\code{src} subdirectory are compiled to produce object (\code{.o}) files
in the \code{build} subdirectory, and those object files are linked
to creat an executable named \code{bin/spider}.

\end{itemize}

\textbf{DO THIS:} Write down other observations or comments about the
\code{serial} code. Feel free to include opinions you may have about the
code or its organization.

\item {} 
Comments in \code{spider.cpp} indicate that two parts of the code need
to be filled in for the crawler program to work. Before actually
fillin that code in, we will see if we can compile and run the code
successfully.

First, insert output statements in those two locations, to indicate
whether those sections of the code are reached. One message might
state ``processing the page x'' where x is the URL of the page being
processed, and the other might state ``crawling the page x''.

Then \code{cd} to the \code{serial} directory, and issue a \code{make} command
in that directory \code{serial}. This should compile the code and create
an executable \code{bin/spider}

\item {} 
Now fill in the missing code for the \code{spider::crawl()} method.
\emph{Notes:}
\begin{itemize}
\item {} 
You will have to use appropriate methods for fetching a web page,
processing that page, and adding that page to the finished
\code{queue}, then adding 1 to the variable named \code{processed}.

\emph{Note:} The method for fetching requires a C-style string
(null-terminated array of characters) for its argument, but the
URL you are crawling is stored in a \code{string} object. Use the
online documentation for \code{string} to look for a method of
\code{string} that returns a C-style string with the same characters
as that \code{string} object.

\item {} 
Do you get the expected output, given that \code{spider::process()}
is still only printing a message?

\end{itemize}

\item {} 
Finally, complete the implementation of the \code{spider::process()}
method, compile, and test. \emph{Note:}
\begin{itemize}
\item {} 
The method \code{spider::is\_image()} currently always returns
\code{false}. In a more sophisticated crawler, this method could
examine file extensions in order to determine whether a URL is an
image (no need to crawl) or not.

\end{itemize}

\item {} 
Change directory to the \code{cds/threads} directory within your lab1
directory.

\begin{Verbatim}[commandchars=\\\{\}]
\% cd \textasciitilde{}/lab1/cds/threads
\end{Verbatim}

\item {} 
First, look at the sequential program \code{primes.cpp} in that
directory. It computes a table of primes up to a maximum number, then
counts the number of primes produced.

\code{primes.cpp} does \emph{not} use threads, but is an ordinary program
with multiple loops.

Then, compile and run the program, using the Makefile provided
(\code{make primes}). Feel free to experiment. \emph{Note:} Be prepared to
wait...

\item {} 
Now, examine the multi-threaded program \code{threads/primes2.cpp}. This
program uses the same algorithm for determining primes, but it
divides the range 2..\code{MAX} up into \code{threadct} non-overlapping
subranges or ``chunks'', and has a separate \code{boost} thread determine
the primes within each chunk. Observe the following:
\begin{itemize}
\item {} 
The loop for determining primes from 2 to \code{MAX}, which was
located in \code{main()} in the program \code{primes.cpp}, has been
relocated to a separate function \code{work()}. That function has two
arguments \code{min} and \code{max}, and the loop has been modified to
check only the subrange \code{min}..\code{max} instead of the entire
range 2..\code{MAX}.

Each thread will execute \code{work()} as if it were a ``main program''
for that thread.

\item {} 
\code{pool} is an array of pointers to \code{boost} threads.

\item {} 
Each \code{boost} thread is initialized with a unique subrange of
2..\code{MAX}. Threads other than the first and the last receive
subranges of length \code{segsize}. The first and last subranges are
treated specially, to insure that the complete computation covers
exactly the range 2..\code{MAX}.

\item {} 
To construct a \code{boost} thread running \code{work()} with arguments
\code{a} and \code{b}, the following constructor call would be used:

\begin{Verbatim}[commandchars=\\\{\}]
thread(boost::bind(work, a, b))
\end{Verbatim}

\item {} 
The call above constructs a thread, but that thread doesn't begin
executing until its \code{join()} method is called. Thus, there is a
separate loop that calls \code{join()} for all the threads in the
array \code{pool}, which starts up all the threads.

\end{itemize}

\item {} 
Now, compile and run the program \code{threads/primes2.cpp}, using the
\code{Makefile} provided (\code{make primes2}). This program takes an
optional positive integer argument, for the thread count (default is
1 thread).

\item {} 
You can time how long a program runs at the Linux or Macintosh
command line by preceding the command with the word \code{time}. For
example, the two commands

\begin{Verbatim}[commandchars=\\\{\}]
\% time primes
\% time primes2 4
\end{Verbatim}

will report the timing for running both the sequential \code{primes}
program, and the multi-threaded \code{primes2} program with four
threads.

Perform time tests of these two programs, for at least one run of
\code{primes}, one run of \code{primes2} with one thread, and one run of
\code{primes2} with 4 threads. Feel free to experiment further.

\item {} 
Examine the code for the program \code{parallel}. Observe the following:
\begin{itemize}
\item {} 
The same four-directory structure is used as for the \code{serial}
directory in the previous lab.

\item {} 
The header files \code{serial/include/page.hpp} and
\code{parallel/include/page.hpp} are identical. You can use the
following \code{diff} command to verify this:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd \textasciitilde{}/SD/lab1
\$ diff serial/include/page.hpp parallel/include/page.hpp
\end{Verbatim}

If the \code{diff} command finds any differences between its two file
arguments, it will report those differences; if there are no
differences, \code{diff} will print nothing.

\end{itemize}

\textbf{DO THIS:} Use the \code{diff} command to compare \code{raw\_page.hpp} and
\code{spider.hpp} for these two versions \code{serial} and \code{parallel}.
\emph{Note:} The \code{diff} program will report differences by printing
lines that appear differently in those files. Lines that appear only
in the first file argument to \code{diff} will be prefixed by \code{\textless{}}, and
lines that appear only in the second file will be prefixed by \code{\textgreater{}}.

Here are differences between \code{serial/include/spider.hpp} and
\code{parallel/include/spider.hpp}.
\begin{itemize}
\item {} 
A different selection of \code{\#include} directives appears in the
two files. In particular,
\begin{itemize}
\item {} 
\code{serial/include/spider.hpp} includes \code{\textless{}queue\textgreater{}}, for the STL
queue container.

\item {} 
\code{parallel/include/spider.hpp} includes three other files
instead of \code{\textless{}queue\textgreater{}}. One refers to a new file
\code{atomic\_counter.hpp} that is part of this program (in the
directory \code{parallel/include}). The others provide two \emph{TBB
containers}, named \code{tbb::concurrent\_queue} and
\code{tbb::concurrent\_vector}

TBB stands for \emph{Intel Threading Building Blocks}, which
provides an alternative implementation of some common
containers. TBB also provides various parallel algorithms, but
we will not use those algorithm features in this lab.

\end{itemize}

\item {} 
The state variables \code{m\_work}, \code{m\_finished}, and \code{m\_pages}
use the TBB container types \code{tbb::concurrent\_queue} or
\code{tbb::concurrent\_vector} instead of the STL containers
\code{std::queue} and \code{std::vector}.

\item {} 
\code{parallel/include/spider.hpp} has two new state variables:
\begin{itemize}
\item {} 
\code{m\_processed}, which has type \code{atomic\_counter} (defined in
\code{atomic\_counter.hpp})

\item {} 
\code{m\_threadCount} of type \code{size\_t}, which is an integer type

\end{itemize}

\item {} 
In \code{parallel}, one of the constructors for \code{spider} has a
second argument of type \code{size\_t}.

\item {} 
There are two new methods, named \code{work()} and \code{work\_once()}.

\end{itemize}

\textbf{Note:} TBB containers are used instead of STL containers because
TBB containers are \emph{thread safe}. This means that multiple threads
can safely interact with a TBB container at the same time without
causing errors. STL containers are \emph{not} thread-safe: with STL
containers, it is possible for two threads to interact with a
container in a way that produces incorrect results.

When the correct behavior of a program depends on timing, we say that
program has a \emph{race condition}. The parallel version of the program
uses TBB containers in order to avoid race conditions. (Race
conditions are discussed in other
\href{http://csinparallel.org/}{CSinParallel} modules.)

Likewise, the state variable \code{m\_processed} has the type
\code{atomic\_counter} instead of \code{int} or \code{long} because the
\code{atomic\_counter} type is thread-safe, enabling us to avoid a race
condition that may arise if multiple threads interact with an integer
variable at about the same time.

\item {} 
The files \code{serial/src/spider.cpp} and \code{parallel/src/spider.cpp}
contain the main differences between these programs -- the
\code{parallel} version uses multiple threads. Running \code{diff} shows
these differences:
\begin{itemize}
\item {} 
In \code{parallel}, one of the constructors for \code{spider} has a
second argument, to specify the number of threads to use.

\item {} 
The counter \code{processed} is a local variable in \code{spider::crawl}
in \code{serial}. This local variable is replaced by a \emph{state
variable} \code{m\_processed} in \code{parallel}.

\item {} 
The main work of \code{crawl} is moved into a method \code{work()} for
the multithreaded version \code{parallel}, and that version creates
\code{threadCount} threads to carry that work out. Note that
\code{work()} has one argument, an integer index of a thread in the
array \code{threads{[}{]}}.

\item {} 
The method \code{spider::process()} and the rest of the code in
\code{spider.cpp} are identical (except for missing code). The
comment within \code{process()} indicates that the same algorithm can
be used for \code{parallel} as for \code{serial}. Why can the same
algorithm be used in the multi-threaded version as in the
sequential version?

\end{itemize}

\item {} 
Fill in the code indicated in two locations for the \code{parallel}
version of \code{spider.cpp}, working from the code you wrote for the
\code{serial} version, as indicated by comments in the \code{parallel}
code. Then compile and run your program.

\emph{Note:} This version of the program requires three command-line
arguments: the maximum number of URLs; the number of threads to use
(this arg is new); and the starting URL to crawl.

Run the program with multiple threads (say, 4 threads). What do you
observe about the run?
\begin{itemize}
\item {} 
You can examine the beginning of the output using the \code{more}
program, e.g.,

\begin{Verbatim}[commandchars=\\\{\}]
\% bin/spider 100 4 www.stolaf.edu \textbar{} more
\end{Verbatim}

Each thread is programmed to print a message such as

\begin{Verbatim}[commandchars=\\\{\}]
Thread 2 finished after processing 29 URLs
\end{Verbatim}

when it completes.

\item {} 
You will probably find that a small number of threads processed
all of the URLs, and that the other threads finished early without
doing any work. How many threads processed URLs in your run? Can
you think of a reason why the others finished early without
processing any URLs? (\emph{Hint:} Think about the work queue near the
beginning of the program, just as the threads are starting their
work.)

\end{itemize}

\item {} 
To spread the computational work out better among the threads,
observe that the method \code{spider::crawl()} includes a call to a
method \code{work\_once()} that has been commented out.

\begin{Verbatim}[commandchars=\\\{\}]
/* work\_once(); */
\end{Verbatim}

Remove those comments, in order to enable that call to
\code{work\_once();} . This will cause the program to process one web
page before beginning multi-thread processing. If that first
processed page includes several links, they will be added to the
queue \code{m\_work}, so that several threads can retrieve web pages to
process when they first begin.

\end{enumerate}


\chapter{Introduction to STL containers}
\label{IntroSTLContainers/introduction_stl_containers:introduction-to-stl-containers}\label{IntroSTLContainers/introduction_stl_containers::doc}
\emph{Note:} This reading refers to topics that we will not pursue in
homework, but which may arise in general C++ coding. Such topics will be
marked\textbf{(Extra)}.


\section{Introduction}
\label{IntroSTLContainers/introduction_stl_containers:introduction}
The C++
\href{http://www.cplusplus.com/reference/stl/}{Standard Template Library}\emph{(STL)}
is a software library of algorithms, data structures, and other features
that can be used with any pre-defined C++ type and with user-defined
types (that provide members such as a copy constructor and an assignment
operator).

The STL uses a C++ feature called the \emph{template} to substitute
types throughout a class or function definition, which enables a
programmer to avoid rewriting definitions that differ in the type being
used.

For example, our IntArray class for homework provides a class
structure around an array of int, with error checking, default
initialization for array elements, whole-array assignment, etc. To
define a class LongArray or FloatArray, we would only need to replace
the type name int by a different type name long or float, etc. Templates
make it possible to define a class Array\textless{}T\textgreater{} in which a type name T is
used thrroughout the definition of that class, so that the notation
Array\textless{}int\textgreater{} would specify a class that behaves just like IntArray,
Array\textless{}float\textgreater{} would specify FloatArray, etc. Here, the angle brackets
\textless{}...\textgreater{} are the syntax for invoking a template, and they enclose a type
name to use throughout a definition.

A programmer can define her/his own templated classes. For
example, here is a complete program with a definition of a templated
structPair\textless{}T\textgreater{} that represents an group of two elements of the same type,
together with an example use of that template.

\begin{Verbatim}[commandchars=\\\{\}]
   \#include \textless{}iostream\textgreater{}
using namespace std;

template \textless{}class T\textgreater{}
struct Pair \PYGZob{}
  T x;
  T y;

  Pair(T val1, T val2) \PYGZob{} x = val1;  y = val2; \PYGZcb{}
\PYGZcb{};


int main() \PYGZob{}
  Pair\textless{}float\textgreater{} p(3.14, -1.0);

  cout \textless{}\textless{} p.x \textless{}\textless{} ", " \textless{}\textless{} p.y \textless{}\textless{} endl;
\PYGZcb{}
\end{Verbatim}

The STL \emph{containers} are templated classes defined in the STL
that are designed to hold objects in some relationship. Examples:
\begin{itemize}
\item {} 
The array classes we have implemented in homework are examples of containers, although STL's array-like container vector\textless{}T\textgreater{} has some added useful features such as an ability to resize incrementally that our array classes did not include.

\item {} 
Another STL container is called a queue\textless{}T\textgreater{}, and contains a linear list of elements that are added at one end and removed at another, comparable to a check-out line of customers at a grocery store. Unlike a vector, the elements of a queue do not necessarily appear consecutively in memory.

\item {} 
\textbf{(Extra)} Another example is the map\textless{}K,T\textgreater{} container, which includes an operator{[}{]} that accepts ``indices'' of a type K (not necessarily an integer type) and associates values of type T with those ``index'' values.

\end{itemize}

This is not a complete list of STL containers, but illustrates
some commonly used ones. See
\href{http://www.cplusplus.com/reference/stl/}{www.cplusplus.com.reference.stl}
for documentation of all STL containers


\section{The STL container vector}
\label{IntroSTLContainers/introduction_stl_containers:the-stl-container-vector}
STL's vector\textless{}T\textgreater{} is a templated class that behaves like an
``elastic array,'' in that its size can be changed incrementally. For
example, consider the following example program:

::
    \#include \textless{}iostream\textgreater{}
    using namespace std;
    \#include \textless{}vector\textgreater{}
    int main() \{
      vector\textless{}int\textgreater{} vec(4);
      vec{[}1{]} = 11;
      vec.at(2) = 22;
      vec.push\_back(33);
      for (int i = 0;  i \textless{} vec.size(); i++)
        cout \textless{}\textless{} vec.at(i) \textless{}\textless{} endl;
    \}

The preprocessor directive

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\#include \textless{}vector\textgreater{}}
\end{Verbatim}

tells the compiler what it needs to know to compile with vectors

The first statement is a variable definition that defines vec to
be a vector of four integers. Each integer location is initialized at 0
by default.

The third statement uses the at() method of vector, and behaves
exactly like operator{[}{]} except for a different style of error handling
(at throws ``exceptions'' instead of crashing the program).

The call to vector's push\_back() method appends a new element 33
to the end of vec

The resulting vector vec contains five int elements: 0, 11, 22,
0, and 33. Those values will be printed by the final loop.

A similar exercise could have been programmed with float, Dog, or
another type.

\textbf{(Extra)} In the ``exception'' style of error handling used by
methods such as at(), a runtime error (i.e., while the program is
running, such as index out of bounds for a vector object) creates an
object called an \emph{exception} that includes information about that error.
We say that the error condition \emph{throws} the exception object. C++
provides an optional try/catch feature for capturing thrown exceptions
and taking action on them; otherwise, throwing an exception causes a
program to crash.

The vector method push\_back() enables a programmer to extend the
length of a vector object by one element, as shown above. That new
element is added at the ``back'' or highest-indexed end of that vector.

Another vector method pop\_back() enables a programmer to delete
the last element of a vector, thus decreasing its length by 1. The
methodpop\_back() requires no argument and returns no value.

The vector index operator {[} {]} and the method at() both provide
immediate access to any element in a vector.

The method size() returns the number of elements currently in a
vector object.

The method back() returns the last element of a non-empty vector.
Thus, vec.back() returns the same value as vec{[}vec.size()-1{]}
orvec.at(vec.size()-1) .

The vector container provides methods for inserting or removing
values at locations other than the back of a vector object, called
insert()and erase(). However, these methods are not as efficient as
push\_back() and pop\_back(). This is because vector elements are stored
consecutively in memory, so inserting or removing an element at a
position other than the back requires copying all element values from
that position through the back value.

\textbf{(Extra)} Note that the methods \emph{insert()} and \emph{erase()}
require iterator objects to specify position within a vector object. An
\emph{iterator} is an object that contains a pointer and has methods for
certain pointer operations, such as a method next() for advancing to the
next element in an array or vector.


\strong{See Also:}


\href{http://www.cplusplus.com/reference/stl/vector}{www.cplusplus.com/reference/stl/vector} for a reference on vectors.




\section{The STL container queue}
\label{IntroSTLContainers/introduction_stl_containers:the-stl-container-queue}
STL's queue\textless{}T\textgreater{} is a templated class that is a \emph{FIFO (first-in
first-out)} container. This means that it is capable of holding an
indeterminate number of elements of a particular type, organized in an
ordered list, with each element added at one end of the list (the
\emph{back}) and removed at the other end (the \emph{front}).

Whereas STL's vector templated class has many methods, a queue
has only six specified methods
(see \href{http://www.cplusplus.com/reference/stl/queue}{www.cplusplus.com/reference/stl/queue}):
\begin{itemize}
\item {} 
push(), which adds an element at the end of a queue,

\item {} 
pop(), which removes an element from the beginning of a queue,

\item {} 
front(), which returns the element at the front of a non-empty queue (next to be popped),

\item {} 
back(), which returns the element at the back of a non-empty queue (most recent to be pushed),

\item {} 
empty(), which returns Boolean True if there are no elements in a queue and False otherwise, and

\item {} 
size(), which returns the number of elements currently in a queue.

\end{itemize}

Here is a code example of using a queue.

\begin{Verbatim}[commandchars=\\\{\}]
\#include \textless{}iostream\textgreater{}
    using namespace std;
\#include \textless{}queue\textgreater{}
int main() \PYGZob{}

      queue\textless{}float\textgreater{} q;
      q.push(1.23);
      q.push(4.56);
      q.push(7.89);
      while (!q.empty()) \PYGZob{}
        cout \textless{}\textless{} q.front() \textless{}\textless{} endl;
        q.pop();
      \PYGZcb{}
\PYGZcb{}
\end{Verbatim}

The output from this code should be the numbers 1.23 \emph{then} 4.56
\emph{then} 7.89, one per line.

An STL vector could be used in a situation where a \emph{queue} would
be appropriate (e.g., simulating a process comparable to a grocery-store
checkout line), using the vector methods push\_back(), front(), and
erase() (to remove the front element). But a queue can be implemented
more efficiently than a vector for this purpose, avoiding the copying of
elements that are needed for vector's erase() method.

\textbf{(Extra)} The underlying data structure for a queue can be
specified when that queue is created, using a second template
parameter.

On the other hand, a queue provides no index or at() operator for
accessing an element other than the front or back elements. The ability
to access arbitrary element locations (e.g., via indices) is called
\emph{random access}, and if random access is needed, a vector may be more
desirable than a queue.

As with vector, the templated container class queue can accept a
user-defined type for its elements. Thus

\begin{Verbatim}[commandchars=\\\{\}]
queue\textless{}Dog\textgreater{} ,  queue\textless{}const Dog\PYGZbs{}*\textgreater{} ,
\end{Verbatim}

and other types may be used.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
