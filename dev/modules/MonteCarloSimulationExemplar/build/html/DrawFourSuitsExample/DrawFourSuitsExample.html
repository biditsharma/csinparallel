<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Drawing Four Cards of the Same Suit &mdash; Monte Carlo Simulation Exemplar</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Monte Carlo Simulation Exemplar" href="../index.html" />
    <link rel="prev" title="What are Monte Carlo Methods?" href="../Introduction/Introduction.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../Introduction/Introduction.html" title="What are Monte Carlo Methods?"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">../../../images/CSInParallel200wide.png</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="drawing-four-cards-of-the-same-suit">
<h1>Drawing Four Cards of the Same Suit<a class="headerlink" href="#drawing-four-cards-of-the-same-suit" title="Permalink to this headline">¶</a></h1>
<p>For our first example, we are interested in the following question: If you are dealt
a random hand of 5 cards, what is the probability that for of the cards have the same
suit? To answer this question, we simulate shuffling a deck of cards and drawing a hand of cards.</p>
<div class="section" id="sequential-code">
<h2>Sequential code<a class="headerlink" href="#sequential-code" title="Permalink to this headline">¶</a></h2>
<p>We represent the deck of cards as an array of integers. Our function for simulating
deck shuffling is not the most effieicent, but it tries to capture how a traditional
&#8220;fan&#8221; shuffle actually works. We also have helper functions for initializing a deck,
drawing a hand, and checking if the hand is a flush.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">randIntBetween</span><span class="p">(</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hi</span><span class="p">){</span>
<span class="c1">//return random number in range [low..hi]</span>
        <span class="k">return</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">hi</span><span class="o">-</span><span class="n">low</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">low</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/************************************************</span>
<span class="cm">***************************** shuffleDeck ******/</span>
<span class="kt">void</span> <span class="nf">shuffleDeck</span><span class="p">(</span><span class="kt">int</span> <span class="n">deck</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">numCards</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//simulate a shuffle like human would do it...</span>
        <span class="kt">int</span> <span class="n">numIn20Percent</span> <span class="o">=</span> <span class="n">numCards</span><span class="o">/</span><span class="mi">5</span><span class="p">;</span>        <span class="c1">//pick somewhere near middle</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="n">numIn20Percent</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="n">numIn20Percent</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">randIntBetween</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>      <span class="c1">//get split point in mid fifth of deck</span>
        <span class="kt">int</span> <span class="n">lowIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">//start of LO half</span>
        <span class="kt">int</span> <span class="n">hiIndex</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>      <span class="c1">//start of HIGH half</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">//loc in &#39;shuffled&#39; deck</span>

        <span class="k">enum</span> <span class="n">STATE</span> <span class="p">{</span><span class="n">MERGE2</span><span class="p">,</span> <span class="n">FLUSH_HIGH</span><span class="p">,</span> <span class="n">FLUSH_LOW</span><span class="p">,</span> <span class="n">DONE</span><span class="p">};</span> <span class="c1">//FSM to simulate fanning shuffle</span>
        <span class="n">STATE</span> <span class="n">myState</span> <span class="o">=</span> <span class="n">MERGE2</span><span class="p">;</span>

        <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">numCards</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numCards</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="c1">//make copy of deck...shuffle back into orig deck</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">deck</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="c1">//FSM simulates a fanning-type shuffle</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">myState</span> <span class="o">!=</span> <span class="n">DONE</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">myState</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">case</span> <span class="n">MERGE2</span>:    <span class="c1">//take one card from a half into new deck</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">//take card from low half</span>
                                        <span class="n">deck</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">lowIndex</span><span class="p">];</span>
                                        <span class="n">lowIndex</span><span class="o">++</span><span class="p">;</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">lowIndex</span> <span class="o">&gt;=</span> <span class="n">mid</span><span class="p">)</span>    <span class="c1">//last card in low half</span>
                                                <span class="n">myState</span> <span class="o">=</span> <span class="n">FLUSH_HIGH</span><span class="p">;</span>
                                <span class="p">}</span><span class="k">else</span> <span class="p">{</span>                         <span class="c1">//take card from hi half</span>
                                        <span class="n">deck</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">[</span><span class="n">hiIndex</span><span class="p">];</span>
                                        <span class="n">hiIndex</span><span class="o">++</span><span class="p">;</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">hiIndex</span> <span class="o">&gt;=</span> <span class="n">numCards</span><span class="p">)</span> <span class="c1">//last card in high half</span>
                                                <span class="n">myState</span> <span class="o">=</span> <span class="n">FLUSH_LOW</span><span class="p">;</span>
                                <span class="p">}</span>
                                <span class="n">index</span><span class="o">++</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="k">case</span> <span class="n">FLUSH_LOW</span>:
                                <span class="k">while</span> <span class="p">(</span><span class="n">index</span><span class="o">&lt;</span><span class="n">numCards</span><span class="p">)</span> <span class="p">{</span><span class="c1">//copy remaining cards in low half</span>
                                        <span class="n">deck</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">lowIndex</span><span class="p">];</span>
                                        <span class="n">lowIndex</span><span class="o">++</span><span class="p">;</span>
                                        <span class="n">index</span><span class="o">++</span><span class="p">;</span>
                                <span class="p">}</span>
                                <span class="n">myState</span> <span class="o">=</span> <span class="n">DONE</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="k">case</span> <span class="n">FLUSH_HIGH</span>:        <span class="c1">//copy remaining cards in high half</span>
                                <span class="k">while</span> <span class="p">(</span><span class="n">index</span><span class="o">&lt;</span><span class="n">numCards</span><span class="p">)</span> <span class="p">{</span>
                                        <span class="n">deck</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">hiIndex</span><span class="p">];</span>
                                        <span class="n">hiIndex</span><span class="o">++</span><span class="p">;</span>
                                        <span class="n">index</span><span class="o">++</span><span class="p">;</span>
                                <span class="p">}</span>
                                <span class="n">myState</span> <span class="o">=</span> <span class="n">DONE</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                        <span class="nl">default:</span>
                                <span class="n">cerr</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Bad state in FSM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
                                <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span><span class="c1">//switch</span>
        <span class="p">}</span><span class="c1">//while</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">//garbage collect</span>
<span class="p">}</span><span class="c1">//shuffle</span>


<span class="cm">/************************************************</span>
<span class="cm">***************************** initDeck *********/</span>
<span class="kt">void</span> <span class="nf">initDeck</span><span class="p">(</span><span class="kt">int</span> <span class="n">deck</span><span class="p">[]){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_CARDS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//load values</span>
                <span class="n">deck</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NUM_SHUFFLES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//shuffle a bunch</span>
                <span class="n">shuffleDeck</span><span class="p">(</span><span class="n">deck</span><span class="p">,</span> <span class="n">MAX_CARDS</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span><span class="c1">//initDeck</span>

<span class="cm">/************************************************</span>
<span class="cm">***************************** pickCard *********/</span>
<span class="kt">int</span> <span class="nf">pickCard</span> <span class="p">(</span><span class="kt">int</span> <span class="n">deck</span><span class="p">[],</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">numCards</span><span class="p">){</span>
<span class="c1">//randomly pick 1 of numCards cards in deck</span>
<span class="c1">//remove card by copying &#39;tail&#39; up one position in ary</span>
        <span class="kt">int</span> <span class="n">loc</span> <span class="o">=</span> <span class="n">randIntBetween</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numCards</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">card</span> <span class="o">=</span> <span class="n">deck</span><span class="p">[</span><span class="n">loc</span><span class="p">];</span>

        <span class="c1">//remove card from deck by copying tail up 1 pos</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numCards</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">deck</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">deck</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">numCards</span><span class="o">--</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">card</span><span class="p">;</span>
<span class="p">}</span><span class="c1">//pickCard</span>


<span class="cm">/************************************************</span>
<span class="cm">***************************** testOneHand *********/</span>
<span class="kt">bool</span> <span class="nf">testOneHand</span><span class="p">(){</span>
<span class="c1">//Create a deck...sort it...pick 4 cards...test 4 suits</span>
        <span class="kt">int</span> <span class="n">deck</span><span class="p">[</span><span class="n">MAX_CARDS</span><span class="p">];</span>    <span class="c1">//std deck</span>
        <span class="kt">int</span> <span class="n">hand</span><span class="p">[</span><span class="n">CARDS_IN_HAND</span><span class="p">];</span>        <span class="c1">//card hand</span>
        
        <span class="n">initDeck</span><span class="p">(</span><span class="n">deck</span><span class="p">);</span> <span class="c1">//create &amp; shuffle a new deck</span>
        
        <span class="n">drawHand</span><span class="p">(</span><span class="n">deck</span><span class="p">,</span> <span class="n">hand</span><span class="p">);</span>   <span class="c1">//go pick cards from deck</span>
        
        <span class="k">return</span> <span class="n">isFourSuits</span><span class="p">(</span><span class="n">hand</span><span class="p">);</span> <span class="c1">//test if 4 suits</span>
<span class="p">}</span><span class="c1">//testOneHand</span>

<span class="cm">/************************************************</span>
<span class="cm">***************************** drawHand *********/</span>
<span class="kt">void</span> <span class="nf">drawHand</span><span class="p">(</span><span class="kt">int</span> <span class="n">deck</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">hand</span><span class="p">[]){</span>
<span class="c1">//pick 5 cards w/out replacement from deck</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">numCards</span> <span class="o">=</span> <span class="n">MAX_CARDS</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">card</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">CARDS_IN_HAND</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">card</span> <span class="o">=</span> <span class="n">pickCard</span><span class="p">(</span><span class="n">deck</span><span class="p">,</span> <span class="n">numCards</span><span class="p">);</span>
                <span class="n">hand</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">card</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span><span class="c1">//drawHand</span>

<span class="c1">//Find largest element in array of size &#39;n&#39;</span>
<span class="kt">int</span> <span class="nf">findBiggest</span><span class="p">(</span><span class="kt">int</span> <span class="n">ary</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">big</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//assume 1st is biggest</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//test remaining elem&#39;s</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ary</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">big</span><span class="p">)</span> 
                        <span class="n">big</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        
        <span class="k">return</span> <span class="n">big</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/************************************************</span>
<span class="cm">***************************** isFourSuits ********/</span>
<span class="kt">bool</span> <span class="nf">isFourSuits</span><span class="p">(</span><span class="kt">int</span> <span class="n">hand</span><span class="p">[]){</span>
<span class="c1">//convert cards to suit value (/ 13)</span>


        <span class="kt">int</span> <span class="n">temp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>        <span class="c1">//one for each suit</span>

        <span class="c1">//copy cards, converting to suit values</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">CARDS_IN_HAND</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">suit</span> <span class="o">=</span> <span class="n">hand</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">13</span><span class="p">;</span>
                <span class="n">temp</span><span class="p">[</span><span class="n">suit</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>  <span class="c1">//count the suits represented</span>
        <span class="p">}</span>
        
        <span class="c1">//if largest #suits == 1 then all 4 suits counted in 4 cards</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">findBiggest</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span><span class="c1">//isTwoPair</span>
</pre></div>
</div>
<p>Using these helper functions, it&#8217;s straightforward was straightforward to write testOneHand,
which initializes a deck, shuffles it, draws a hand, and then checks if it is a flush.</p>
</div>
<div class="section" id="open-mp-version">
<h2>Open MP Version<a class="headerlink" href="#open-mp-version" title="Permalink to this headline">¶</a></h2>
<p>Converting our sequential code to use OpenMP is quite simple. We add a pragma
compiler directive to the main simulation loop to run the loop simultaneously
on multiple CPUs. The directive tells OpenMP to give each thread a different
copy of i since each thread needs to keep track of its own loop iterations.
numTests is shared because the total number of tests to run is doubled only
once per iteration of the out while loop. (If each thread doubled it, we would
go up by more than a factor of two.) Finally, the directive &#8216;reduction (+:total)&#8217;
tells OpenMP to combine each of the threads&#8217; partial results by summing to find
the total number of hands that were flushes.</p>
<div class="highlight-c++"><div class="highlight"><pre>        <span class="k">while</span> <span class="p">(</span><span class="n">numTests</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">//reset counter</span>
<span class="cp">#pragma omp parallel for default(none) \</span>
<span class="cp">        private (i) \</span>
<span class="cp">        shared (numTests) \</span>
<span class="cp">        reduction (+:total)</span>
                
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numTests</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//make new deck - pick hand - test for 4 suits</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">testOneHand</span><span class="p">())</span>              <span class="c1">//returns TRUE iff 4-suits hand</span>
                                <span class="n">total</span> <span class="o">++</span><span class="p">;</span>               <span class="c1">//tally hands with 4-suits</span>
                <span class="p">}</span>
                <span class="c1">//calc % of 4-suit hands &amp; report results...</span>
                <span class="n">percentage</span> <span class="o">=</span> <span class="mf">100.0</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">total</span><span class="p">)</span><span class="o">/</span><span class="n">numTests</span><span class="p">;</span>
                <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">setw</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">numTests</span><span class="o">&lt;&lt;</span><span class="n">setw</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">setprecision</span><span class="p">(</span><span class="mi">3</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">fixed</span><span class="o">&lt;&lt;</span><span class="n">percentage</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">numTests</span> <span class="o">+=</span> <span class="n">numTests</span><span class="p">;</span>   <span class="c1">//double #tests for next round</span>
        <span class="p">}</span><span class="c1">//while</span>
</pre></div>
</div>
</div>
<div class="section" id="mpich-version">
<h2>MPICH Version<a class="headerlink" href="#mpich-version" title="Permalink to this headline">¶</a></h2>
<p>Converting the sequential code to use MPICH instead is only slightly more difficult
than using OpenMp. First we have to initialize MPI and calculate the number of tests
each instance needs to run:</p>
<div class="highlight-python"><div class="highlight"><pre>MPI_Init(&amp;argc, &amp;argv);
MPI_Comm_size(MPI_COMM_WORLD, &amp;size);
MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
...
testsToRun = numTests/size;
if(rank == size - 1) testsToRun += numTest % size //assign remaining tests to last worker
</pre></div>
</div>
<p>Then, each instance runs a separate simulation loop as before. The other difference
is we need to explictly send the partial results from each worker to the Master instance.
The Master node sums the partial results and displays the answer:</p>
<div class="highlight-c++"><div class="highlight"><pre>		<span class="c1">//The Master collects results and sums them</span>
		<span class="k">if</span><span class="p">(</span><span class="n">rank</span> <span class="o">==</span> <span class="n">MASTER</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mtype</span> <span class="o">=</span> <span class="n">FROM_MASTER</span><span class="p">;</span>
			<span class="n">total</span> <span class="o">=</span> <span class="n">partialSum</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">source</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">source</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">dest</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">MPI_Recv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">partialSum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">mtype</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
				<span class="n">total</span> <span class="o">+=</span> <span class="n">partialSum</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="c1">//Each work sends its partial sum to the Master</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">mtype</span> <span class="o">=</span> <span class="n">FROM_WORKER</span><span class="p">;</span>
			<span class="n">MPI_Send</span><span class="p">(</span><span class="o">&amp;</span><span class="n">partialSum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="n">MASTER</span><span class="p">,</span> <span class="n">mtype</span><span class="p">,</span> <span class="n">MPI_COMM_WORLD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>

		<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cuda-version">
<h2>Cuda Version<a class="headerlink" href="#cuda-version" title="Permalink to this headline">¶</a></h2>
<p>The changes needed to run the code with CUDA are slightly more involved. We have several
issues we have to deal with. First, we have to copy our results to and from the the device.
The other issue is that we can&#8217;t use the standard random library from the device.
Fortunately, Nvidia provides build in libraries for generating random numbers on a GPU.
You can get more information about the CUDA random library at: <a class="reference external" href="http://docs.nvidia.com/cuda/curand/introduction.html">http://docs.nvidia.com/cuda/curand/introduction.html</a> We allocate space on the GPU for a random number generator for
each thread and the result:</p>
<div class="highlight-python"><div class="highlight"><pre>cudaMalloc((void **)&amp;devStates, sizeof(curandState)*BLOCK_SIZE);
cudaMalloc((void **)&amp;dev_result, sizeof(unsigned int));
cudaDeviceSynchronize();
</pre></div>
</div>
<p>We define a new function, run_simulations that runs simulations on the GPU:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">__global__</span> <span class="kt">void</span> <span class="nf">run_simulations</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">curandState</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">thread2</span><span class="p">,</span> <span class="n">halfPoint</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nTotalThreads</span> <span class="o">=</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	<span class="n">__shared__</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">[</span><span class="n">BLOCK_SIZE</span><span class="p">];</span> 
	<span class="kt">int</span> <span class="n">nTrials</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nTotalThreads</span><span class="p">;</span> 
	<span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nTrials</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">nTotalThreads</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">curand_init</span><span class="p">(</span><span class="mi">1235</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nTrials</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">testOneHand</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="p">[</span><span class="n">id</span><span class="p">]))</span> <span class="p">{</span> 
			<span class="n">tot</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="n">sum</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tot</span><span class="p">;</span>
	<span class="n">__syncthreads</span><span class="p">();</span>
	<span class="k">while</span><span class="p">(</span><span class="n">nTotalThreads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">halfPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">nTotalThreads</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">halfPoint</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">thread2</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">halfPoint</span><span class="p">;</span>
			<span class="n">sum</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">[</span><span class="n">thread2</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">__syncthreads</span><span class="p">();</span>
		<span class="n">nTotalThreads</span> <span class="o">=</span> <span class="n">halfPoint</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>From this function, we call the other helper function, so we add the __device__
directive to them to allow them to be called on the GPU:</p>
<p>Here is the source code for this section:
<a class="reference download internal" href="../_downloads/drawFourSuitsSequential.cpp"><tt class="xref download docutils literal"><span class="pre">drawFourSuitsSequential.cpp</span></tt></a>
<a class="reference download internal" href="../_downloads/drawFourSuitsOpenMP.cpp"><tt class="xref download docutils literal"><span class="pre">drawFourSuitsOpenMP.cpp</span></tt></a>
<a class="reference download internal" href="../_downloads/drawFourSuitsMPI.cpp"><tt class="xref download docutils literal"><span class="pre">drawFourSuitsMPI.cpp</span></tt></a>
<a class="reference download internal" href="../_downloads/drawFourSuitsCuda.cu"><tt class="xref download docutils literal"><span class="pre">drawFourSuitsCuda.cu</span></tt></a></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Drawing Four Cards of the Same Suit</a><ul>
<li><a class="reference internal" href="#sequential-code">Sequential code</a></li>
<li><a class="reference internal" href="#open-mp-version">Open MP Version</a></li>
<li><a class="reference internal" href="#mpich-version">MPICH Version</a></li>
<li><a class="reference internal" href="#cuda-version">Cuda Version</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../Introduction/Introduction.html"
                        title="previous chapter">What are Monte Carlo Methods?</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../Introduction/Introduction.html" title="What are Monte Carlo Methods?"
             >previous</a> |</li>
        <li><a href="../index.html">../../../images/CSInParallel200wide.png</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>