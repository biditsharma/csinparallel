************
Introduction
************

Moore's law notes that processing power doubles about every two years. Computers have seen the benefit of this observation since the 1970's, as we have increased the number of transistors on a chip and the clock speed of the chips. However, physical limitations with heat and space have limited our potential to improve individual processors, and now we focus on putting more core processing elements on each chip.

We can easily take advantage of a few processors by assigning each core to a different program, but as we build computers with more processors and write programs with higher computational needs, we run into limits with traditional programming. We need to write code in such a way that one application can take advantage of many processors.

We can use the Java API to parallelize programs. We will focus on a class for writing multi-threaded programs called java.lang.Thread, which deals with individual threads of execution running concurrently.

After we create a Thread object, it will start execution when we call its start() method. Calling this method marks the Thread object ready, and it returns so that the caller can continue execution. This Thread that we just started will execute its run() method so that it runs concurrently to the caller. The caller (or possibly some other piece of code) could wait for the Thread to finish by calling the Thread's join() method, which will block the caller until the Thread's run() method returns.

A Thread object's default run() method will do nothing and return immediately, so we need to specify what a Thread will do. We could do this by creating a class extending Thread and then override run(). Alternatively, we could create a class implementing the Runnable interface, which contains a single method run(). Then we can pass a Runnable object to the constructor of Thread, which will cause that Thread's run() method to invoke the run() method of the Runnable object. This lab will use the second approach.

We can use Thread objects to easily create a program with multiple threads, but this comes with some complications. The different Threads will usually need to communicate or share data in order to accomplish a shared goal, which may seem simple because they share and address space and they can share variables. However, we need to make sure to avoid race conditions where one thread accesses data in the middle of the process of another thread changing that data. Java provides a simple way to avoid this situation. The keyword synchronized creates a code block that locks at the beginning of a block, runs the code in the block, and then releases the lock. For example:
